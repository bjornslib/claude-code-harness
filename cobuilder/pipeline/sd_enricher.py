"""SD v2 enrichment writer — appends CoBuilder enrichment blocks to SD files."""

import logging
import re
from pathlib import Path
from typing import Optional

from cobuilder.pipeline.taskmaster_bridge import extract_task_ids_for_node

logger = logging.getLogger(__name__)

ENRICHMENT_MARKER = "## CoBuilder Enrichment"
FEATURE_HEADER = re.compile(r'^(#{1,3})\s+(F\d+\.\d+)[:\s]', re.MULTILINE)


def _build_enrichment_block(
    feature_id: str,
    feature_title: str,
    node: dict,
    bead_id: str = "",
    taskmaster_tasks: list = None,
) -> str:
    """Build the YAML enrichment block string."""
    taskmaster_tasks = taskmaster_tasks or []
    file_scope = node.get("file_scope", {"modify": [], "create": [], "reference_only": []})
    acceptance = node.get("acceptance_criteria", [])

    block_lines = [
        "",
        f"## CoBuilder Enrichment — {feature_id}: {feature_title}",
        "<!-- Auto-generated by cobuilder pipeline create — do not manually edit -->",
        "",
        "```yaml",
        f"pipeline_node: {node.get('node_id', '')}",
        f"bead_id: {bead_id}",
        f"worker_type: {node.get('worker_type', 'backend-solutions-engineer')}",
        f"delta_status: {node.get('delta_status', 'unknown')}",
    ]

    if taskmaster_tasks:
        block_lines.append("taskmaster_tasks:")
        for t in taskmaster_tasks:
            block_lines.append(f"  - id: {t.get('id')}")
            block_lines.append(f"    title: \"{t.get('title', '')}\"")
    else:
        block_lines.append("taskmaster_tasks: []")

    # file_scope
    block_lines.append("file_scope:")
    block_lines.append("  modify:")
    for f in file_scope.get("modify", []):
        block_lines.append(f"    - path: {f.get('path', '')}")
        block_lines.append(f"      reason: \"{f.get('reason', '')}\"")
    block_lines.append("  create:")
    for f in file_scope.get("create", []):
        block_lines.append(f"    - path: {f.get('path', '')}")
        block_lines.append(f"      reason: \"{f.get('reason', '')}\"")
    block_lines.append("  reference_only:")
    for f in file_scope.get("reference_only", []):
        block_lines.append(f"    - {f}")

    # acceptance criteria
    block_lines.append("acceptance_criteria_enriched:")
    for ac in acceptance:
        criterion = ac.get("criterion", str(ac)) if isinstance(ac, dict) else str(ac)
        block_lines.append(f"  - \"{criterion}\"")

    block_lines.append("```")
    block_lines.append("")
    return "\n".join(block_lines)


def write_enrichment_block(
    sd_path: str,
    feature_id: str,
    node: dict,
    bead_id: str = "",
    taskmaster_tasks: list = None,
) -> bool:
    """Append or replace a CoBuilder enrichment block in the SD file.

    Returns True if written, False if feature section not found.
    """
    path = Path(sd_path)
    if not path.exists():
        logger.warning("SD file not found: %s", sd_path)
        return False

    content = path.read_text(encoding="utf-8")

    # Find feature section header
    match = None
    for m in FEATURE_HEADER.finditer(content):
        if m.group(2) == feature_id:
            match = m
            break

    if not match:
        logger.debug("Feature section %s not found in %s", feature_id, sd_path)
        return False

    # Extract feature title from the header line
    header_line_end = content.index('\n', match.start()) if '\n' in content[match.start():] else len(content)
    header_line = content[match.start():header_line_end]
    feature_title = re.sub(r'^#{1,3}\s+F\d+\.\d+[:\s]*', '', header_line).strip()

    block = _build_enrichment_block(feature_id, feature_title, node, bead_id, taskmaster_tasks)

    # Check if enrichment block already exists for this feature
    marker = f"## CoBuilder Enrichment — {feature_id}:"
    if marker in content:
        # Replace existing block
        marker_pos = content.index(marker)
        after_marker = content[marker_pos:]
        # Find closing ``` after the opening ```yaml
        yaml_open = after_marker.find("```yaml\n")
        if yaml_open == -1:
            block_end = len(content)
        else:
            code_end = after_marker.find("```\n", yaml_open + len("```yaml\n"))
            if code_end == -1:
                block_end = len(content)
            else:
                block_end = marker_pos + code_end + 4  # +4 for "```\n"

        # Find next section after block
        rest = content[block_end:]
        next_section = re.search(r'\n## ', rest)
        if next_section:
            block_end += next_section.start()

        content = content[:marker_pos] + block + content[block_end:]
    else:
        # Insert after the feature section (before next section of same/higher level)
        feature_end = match.end()
        # Find next section header at same or higher level
        level = len(match.group(1))  # number of #
        next_section_pattern = re.compile(r'\n#{1,' + str(level) + r'}\s+', re.MULTILINE)
        next_match = next_section_pattern.search(content, feature_end)

        if next_match:
            insert_pos = next_match.start()
        else:
            insert_pos = len(content)

        content = content[:insert_pos] + "\n" + block + content[insert_pos:]

    path.write_text(content, encoding="utf-8")
    logger.info("Wrote enrichment block for %s to %s", feature_id, sd_path)
    return True


def write_all_enrichments(
    sd_path: str,
    enriched_nodes: list[dict],
    taskmaster_tasks: dict = None,
) -> int:
    """Write enrichment blocks for all enriched nodes. Returns count written."""
    taskmaster_tasks = taskmaster_tasks or {}
    count = 0

    for node in enriched_nodes:
        # Try to match feature_id from node metadata
        feature_id = node.get("feature_id", "")
        if not feature_id:
            continue

        bead_id = node.get("bead_id", "")
        tm_tasks = (
            extract_task_ids_for_node(taskmaster_tasks, node.get("title", ""))
            if taskmaster_tasks
            else []
        )

        if write_enrichment_block(sd_path, feature_id, node, bead_id, tm_tasks):
            count += 1

    return count
