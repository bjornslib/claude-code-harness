#!/bin/bash
# cs-verify - Verify completion promises and check session readiness
#
# Usage:
#   cs-verify --promise <id>                           # Verify (requires all ACs met)
#   cs-verify --promise <id> --proof "Summary note"    # Verify with optional summary
#   cs-verify --promise <id> --type test               # Verify with verification type
#   cs-verify --check                                  # Check if session can end (for StopHook)
#   cs-verify --check --verbose                        # Detailed check output with per-AC detail
#
# Verification types:
#   test     - Verified via automated tests
#   browser  - Verified via browser/E2E testing
#   api      - Verified via API testing
#   manual   - Verified manually by user
#
# Acceptance Criteria Enforcement:
#   If a promise has acceptance_criteria, ALL must have status "met" before
#   verification succeeds. Use cs-promise --meet to submit evidence per criterion.
#   Legacy promises (no acceptance_criteria) require --proof for verification.
#
# After verification, the promise is moved to history.
#
# Environment:
#   CLAUDE_SESSION_ID - Current session identifier (set via cs-init)

set -e

STATE_DIR="${CLAUDE_PROJECT_DIR:-$(pwd)}/.claude/completion-state"
PROMISES_DIR="$STATE_DIR/promises"
HISTORY_DIR="$STATE_DIR/history"

# Require session ID
require_session_id() {
    if [ -z "$CLAUDE_SESSION_ID" ]; then
        echo "Error: CLAUDE_SESSION_ID not set. Run: eval \"\$(cs-init)\"" >&2
        exit 1
    fi
}

# Get current timestamp
get_timestamp() {
    python3 -c 'import datetime; print(datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%dT%H:%M:%SZ"))'
}

# Parse arguments
MODE=""
PROMISE_ID=""
PROOF=""
VERIFY_TYPE="manual"
CHECK_MODE=false
VERBOSE=false
LLM_VERIFY=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --promise)
            MODE="verify"
            PROMISE_ID="$2"
            shift 2
            ;;
        --proof)
            PROOF="$2"
            shift 2
            ;;
        --type)
            VERIFY_TYPE="$2"
            shift 2
            ;;
        --check)
            CHECK_MODE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --task-id|--task_id)
            TASK_ID="$2"
            shift 2
            ;;
        --llm-verify)
            LLM_VERIFY=true
            shift
            ;;
        --help)
            echo "cs-verify - Verify completion promises"
            echo ""
            echo "Usage:"
            echo "  cs-verify --promise <id>                      Verify (all ACs must be met)"
            echo "  cs-verify --promise <id> --proof \"Summary\"    Verify with optional summary note"
            echo "  cs-verify --promise <id> --type test          Verify with verification type"
            echo "  cs-verify --check                             Check if session can end"
            echo "  cs-verify --check --verbose                   Detailed check with per-AC detail"
            echo ""
            echo "Options:"
            echo "  --promise <id>   Promise ID to verify"
            echo "  --proof <text>   Optional summary note (required for legacy promises without ACs)"
            echo "  --type <type>    Verification type: test, browser, api, manual (default: manual)"
            echo "  --task-id <id>   Also add comment to beads task (atomic update)"
            echo "  --check          Evaluate if session can end (for StopHook)"
            echo "  --verbose        Show detailed output"
            echo "  --llm-verify     Run LLM programmatic verification (Gate 3)"
            echo ""
            echo "Acceptance Criteria:"
            echo "  If a promise has acceptance_criteria, ALL must have status \"met\"."
            echo "  Submit evidence per criterion: cs-promise --meet <id> --ac-id AC-X --evidence \"...\""
            echo "  Legacy promises (no acceptance_criteria) require --proof for verification."
            echo ""
            echo "Exit codes for --check:"
            echo "  0  Session can end (all owned promises verified)"
            echo "  2  Session cannot end (unverified promises remain)"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Run 'cs-verify --help' for usage." >&2
            exit 1
            ;;
    esac
done

# Ensure directories exist
mkdir -p "$PROMISES_DIR"
mkdir -p "$HISTORY_DIR"

# Add comment to beads task if task_id provided
add_beads_comment() {
    local task_id="$1"
    local comment="$2"

    if [ -z "$task_id" ]; then
        return 0
    fi

    # Use bd comment to add the verification evidence
    cd "${CLAUDE_PROJECT_DIR:-$(pwd)}" && cd .. && \
        bd comment add "$task_id" "$comment" 2>/dev/null || {
            echo "Warning: Could not add comment to beads task $task_id" >&2
        }
}

# Handle --check mode (for StopHook)
if [ "$CHECK_MODE" = true ]; then
    require_session_id

    # Find all promises owned by this session
    MY_PROMISES=()
    IN_PROGRESS_COUNT=0
    PENDING_COUNT=0

    if [ -d "$PROMISES_DIR" ] && [ -n "$(ls -A "$PROMISES_DIR" 2>/dev/null)" ]; then
        for f in "$PROMISES_DIR"/*.json; do
            [ -f "$f" ] || continue
            OWNER=$(jq -r '.ownership.owned_by // "null"' "$f")
            if [ "$OWNER" = "$CLAUDE_SESSION_ID" ]; then
                ID=$(jq -r '.id' "$f")
                STATUS=$(jq -r '.status' "$f")
                SUMMARY=$(jq -r '.summary' "$f" | head -c 50)
                MY_PROMISES+=("$ID:$STATUS:$SUMMARY")

                if [ "$STATUS" = "in_progress" ]; then
                    IN_PROGRESS_COUNT=$((IN_PROGRESS_COUNT + 1))
                elif [ "$STATUS" = "pending" ]; then
                    PENDING_COUNT=$((PENDING_COUNT + 1))
                fi
            fi
        done
    fi

    # Check for orphaned in_progress promises (warn but don't block)
    ORPHAN_COUNT=0
    if [ -d "$PROMISES_DIR" ] && [ -n "$(ls -A "$PROMISES_DIR" 2>/dev/null)" ]; then
        for f in "$PROMISES_DIR"/*.json; do
            [ -f "$f" ] || continue
            OWNER=$(jq -r '.ownership.owned_by // "null"' "$f")
            STATUS=$(jq -r '.status' "$f")
            if [ "$OWNER" = "null" ] && [ "$STATUS" = "in_progress" ]; then
                ORPHAN_COUNT=$((ORPHAN_COUNT + 1))
                if [ "$VERBOSE" = true ]; then
                    ID=$(jq -r '.id' "$f")
                    SUMMARY=$(jq -r '.summary' "$f" | head -c 50)
                    echo "WARNING: Orphaned in_progress promise: $ID" >&2
                    echo "  \"$SUMMARY...\"" >&2
                fi
            fi
        done
    fi

    # No owned promises = can exit
    if [ ${#MY_PROMISES[@]} -eq 0 ]; then
        if [ "$VERBOSE" = true ]; then
            echo "No promises owned by this session."
        fi
        if [ $ORPHAN_COUNT -gt 0 ]; then
            echo "WARNING: $ORPHAN_COUNT orphaned in_progress promise(s) detected." >&2
            echo "Run 'cs-promise --list' to see them." >&2
        fi
        exit 0
    fi

    # All owned promises are verified/cancelled = can exit
    if [ $IN_PROGRESS_COUNT -eq 0 ] && [ $PENDING_COUNT -eq 0 ]; then
        if [ "$VERBOSE" = true ]; then
            echo "All owned promises are complete."
        fi
        exit 0
    fi

    # Have unverified promises - block exit
    echo "COMPLETION CRITERIA NOT MET"
    echo ""
    echo "Session: $CLAUDE_SESSION_ID"
    echo ""

    # Track first unmet criterion for NEXT ACTION hint
    FIRST_UNMET_PROMISE=""
    FIRST_UNMET_AC_ID=""

    if [ $IN_PROGRESS_COUNT -gt 0 ]; then
        echo "IN_PROGRESS PROMISES ($IN_PROGRESS_COUNT):"
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "in_progress" ]; then
                PFILE="$PROMISES_DIR/$ID.json"
                echo "  $ID: \"$SUMMARY...\""

                # Show per-criterion detail if acceptance_criteria exist
                if [ -f "$PFILE" ]; then
                    P_HAS_AC=$(jq 'has("acceptance_criteria") and (.acceptance_criteria | length > 0)' "$PFILE")
                    if [ "$P_HAS_AC" = "true" ]; then
                        P_TOTAL=$(jq '.acceptance_criteria | length' "$PFILE")
                        P_MET=$(jq '[.acceptance_criteria[] | select(.status == "met")] | length' "$PFILE")
                        # Show each criterion with status
                        while IFS=$'\t' read -r AC_STATUS AC_ID AC_DESC; do
                            if [ "$AC_STATUS" = "met" ]; then
                                echo "    [MET]     $AC_ID: $AC_DESC"
                            else
                                echo "    [PENDING] $AC_ID: $AC_DESC"
                                # Track first unmet for NEXT ACTION
                                if [ -z "$FIRST_UNMET_PROMISE" ]; then
                                    FIRST_UNMET_PROMISE="$ID"
                                    FIRST_UNMET_AC_ID="$AC_ID"
                                fi
                            fi
                        done < <(jq -r '.acceptance_criteria[] | [.status, .id, .description] | @tsv' "$PFILE")
                        echo "    Progress: $P_MET/$P_TOTAL criteria met"
                    fi
                fi
            fi
        done
        echo ""
    fi

    if [ $PENDING_COUNT -gt 0 ]; then
        echo "PENDING PROMISES ($PENDING_COUNT):"
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "pending" ]; then
                echo "  $ID: \"$SUMMARY...\""
            fi
        done
        echo ""
    fi

    echo "NEXT ACTION:"
    if [ -n "$FIRST_UNMET_PROMISE" ]; then
        # Has unmet acceptance criteria — point to cs-promise --meet
        echo "  Submit evidence: cs-promise --meet $FIRST_UNMET_PROMISE --ac-id $FIRST_UNMET_AC_ID --evidence \"...\" --type test"
    else
        # No AC detail available — fall back to original hint
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "in_progress" ]; then
                echo "  Complete and verify: cs-verify --promise $ID --proof \"...\""
                break
            elif [ "$STATUS" = "pending" ]; then
                echo "  Start work: cs-promise --start $ID"
                break
            fi
        done
    fi

    if [ $ORPHAN_COUNT -gt 0 ]; then
        echo ""
        echo "WARNING: $ORPHAN_COUNT orphaned in_progress promise(s) detected."
        echo "Consider adopting or investigating crashed sessions."
    fi

    # Exit 2 to block stop
    exit 2
fi

# Handle verification mode
if [ "$MODE" != "verify" ]; then
    echo "Error: Must specify --promise or --check" >&2
    exit 1
fi

require_session_id

if [ -z "$PROMISE_ID" ]; then
    echo "Error: --promise requires an ID" >&2
    exit 1
fi

# Validate verification type
case $VERIFY_TYPE in
    test|browser|api|manual) ;;
    *)
        echo "Error: Invalid verification type: $VERIFY_TYPE" >&2
        echo "Valid types: test, browser, api, manual" >&2
        exit 1
        ;;
esac

PROMISE_FILE="$PROMISES_DIR/$PROMISE_ID.json"
if [ ! -f "$PROMISE_FILE" ]; then
    echo "Error: Promise not found: $PROMISE_ID" >&2
    exit 1
fi

# Check ownership
OWNER=$(jq -r '.ownership.owned_by // "null"' "$PROMISE_FILE")
if [ "$OWNER" != "$CLAUDE_SESSION_ID" ]; then
    echo "Error: You don't own this promise. Current owner: $OWNER" >&2
    echo "Use 'cs-promise --adopt $PROMISE_ID' to claim it first." >&2
    exit 1
fi

# Check current status
CURRENT_STATUS=$(jq -r '.status' "$PROMISE_FILE")
if [ "$CURRENT_STATUS" = "verified" ]; then
    echo "Error: Promise is already verified." >&2
    exit 1
fi

if [ "$CURRENT_STATUS" = "cancelled" ]; then
    echo "Error: Cannot verify a cancelled promise." >&2
    exit 1
fi

if [ "$CURRENT_STATUS" = "pending" ]; then
    echo "Note: Promise was pending. Setting to in_progress before verifying." >&2
fi

# Check if promise has acceptance_criteria
HAS_AC=$(jq 'has("acceptance_criteria") and (.acceptance_criteria | length > 0)' "$PROMISE_FILE")

if [ "$HAS_AC" = "true" ]; then
    # Promise has acceptance criteria - check all are met
    TOTAL_AC=$(jq '.acceptance_criteria | length' "$PROMISE_FILE")
    MET_AC=$(jq '[.acceptance_criteria[] | select(.status == "met")] | length' "$PROMISE_FILE")
    PENDING_AC=$((TOTAL_AC - MET_AC))

    if [ $PENDING_AC -gt 0 ]; then
        echo "Error: Cannot verify $PROMISE_ID — $PENDING_AC of $TOTAL_AC criteria still pending:" >&2
        echo "" >&2
        # List unmet criteria
        jq -r '.acceptance_criteria[] | select(.status != "met") | "  [PENDING] \(.id): \(.description)"' "$PROMISE_FILE" >&2
        echo "" >&2
        # Show hint for first unmet criterion
        FIRST_UNMET_ID=$(jq -r '[.acceptance_criteria[] | select(.status != "met")][0].id' "$PROMISE_FILE")
        echo "Submit evidence for each criterion first:" >&2
        echo "  cs-promise --meet $PROMISE_ID --ac-id $FIRST_UNMET_ID --evidence \"...\" --type test" >&2
        exit 1
    fi
    # All ACs met — --proof is optional (stored as summary note if provided)
else
    # Legacy promise (no acceptance_criteria) — --proof is required
    if [ -z "$PROOF" ]; then
        echo "Error: --proof is required for legacy promises without acceptance criteria" >&2
        exit 1
    fi
fi

# LLM verification gate (Gate 3 in triple-gate validation)
if [ "$LLM_VERIFY" = true ]; then
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    LLM_SCRIPT="$SCRIPT_DIR/cs-verify-llm.py"

    if [ ! -f "$LLM_SCRIPT" ]; then
        echo "WARNING: LLM verification script not found at $LLM_SCRIPT" >&2
        echo "Proceeding without LLM verification." >&2
    else
        echo "Running LLM verification gate..."

        # Extract criteria JSON from promise file
        CRITERIA_JSON=$(jq -c '.acceptance_criteria' "$PROMISE_FILE")

        # Call LLM verification
        LLM_RESULT=$("$LLM_SCRIPT" \
            --summary "$SUMMARY" \
            --criteria "$CRITERIA_JSON" \
            ${PROOF:+--proof "$PROOF"} 2>/dev/null) || true

        if [ -n "$LLM_RESULT" ]; then
            LLM_VERDICT=$(echo "$LLM_RESULT" | jq -r '.verdict // "WARN"')
            LLM_REASONING=$(echo "$LLM_RESULT" | jq -r '.reasoning // "No response"')
            LLM_CONFIDENCE=$(echo "$LLM_RESULT" | jq -r '.confidence // "N/A"')
            LLM_COST=$(echo "$LLM_RESULT" | jq -r '.cost_estimate_usd // "N/A"')

            if [ "$LLM_VERDICT" = "FAIL" ]; then
                echo "" >&2
                echo "LLM VERIFICATION FAILED" >&2
                echo "Reasoning: $LLM_REASONING" >&2
                echo "Confidence: $LLM_CONFIDENCE" >&2
                echo "" >&2
                echo "The programmatic judge rejected this verification." >&2
                echo "Address the issues above and try again." >&2
                exit 1
            elif [ "$LLM_VERDICT" = "WARN" ]; then
                echo "WARNING: LLM verification unavailable. $LLM_REASONING" >&2
                echo "Proceeding with manual verification only." >&2
            else
                echo "LLM verification: PASS (confidence: $LLM_CONFIDENCE, cost: \$$LLM_COST)"
            fi
        else
            echo "WARNING: LLM verification returned empty result." >&2
            echo "Proceeding with manual verification only." >&2
        fi
    fi
fi

TIMESTAMP=$(get_timestamp)
SUMMARY=$(jq -r '.summary' "$PROMISE_FILE")

# Update promise with verification
if [ -n "$PROOF" ]; then
    jq --arg ts "$TIMESTAMP" \
       --arg session "$CLAUDE_SESSION_ID" \
       --arg type "$VERIFY_TYPE" \
       --arg proof "$PROOF" '
        .status = "verified" |
        .verification.verified_at = $ts |
        .verification.verified_by = $session |
        .verification.type = $type |
        .verification.proof = $proof
    ' "$PROMISE_FILE" > "$PROMISE_FILE.tmp" && mv "$PROMISE_FILE.tmp" "$PROMISE_FILE"
else
    jq --arg ts "$TIMESTAMP" \
       --arg session "$CLAUDE_SESSION_ID" \
       --arg type "$VERIFY_TYPE" '
        .status = "verified" |
        .verification.verified_at = $ts |
        .verification.verified_by = $session |
        .verification.type = $type
    ' "$PROMISE_FILE" > "$PROMISE_FILE.tmp" && mv "$PROMISE_FILE.tmp" "$PROMISE_FILE"
fi

# Move to history
mv "$PROMISE_FILE" "$HISTORY_DIR/"

echo "VERIFIED: $PROMISE_ID"
echo ""
echo "Summary: $SUMMARY"
echo "Type: $VERIFY_TYPE"
if [ -n "$PROOF" ]; then
    echo "Proof: $PROOF"
fi
if [ "$HAS_AC" = "true" ]; then
    echo "Acceptance Criteria: $TOTAL_AC/$TOTAL_AC met"
fi
echo "Verified by: $CLAUDE_SESSION_ID"
echo "Verified at: $TIMESTAMP"
echo ""
echo "Promise moved to history."

# Add comment to beads task if --task-id was provided
if [ -n "$TASK_ID" ]; then
    COMMENT="[cs-verify] Type: $VERIFY_TYPE | Session: $CLAUDE_SESSION_ID | Time: $TIMESTAMP"
    if [ -n "$PROOF" ]; then
        COMMENT="$COMMENT | Proof: $PROOF"
    fi
    if [ "$HAS_AC" = "true" ]; then
        COMMENT="$COMMENT | ACs: $TOTAL_AC/$TOTAL_AC met"
    fi
    add_beads_comment "$TASK_ID" "$COMMENT"
    echo ""
    echo "Added verification comment to beads task: $TASK_ID"
fi
