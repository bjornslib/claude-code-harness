#!/bin/bash
# cs-verify - Verify completion promises and check session readiness
#
# Usage:
#   cs-verify --promise <id>                           # Verify (requires all ACs met)
#   cs-verify --promise <id> --proof "Summary note"    # Verify with optional summary
#   cs-verify --promise <id> --type test               # Verify with verification type
#   cs-verify --check                                  # Check if session can end (for StopHook)
#   cs-verify --check --verbose                        # Detailed check output with per-AC detail
#
# Verification types:
#   test     - Verified via automated tests
#   browser  - Verified via browser/E2E testing
#   api      - Verified via API testing
#   manual   - Verified manually by user
#
# Acceptance Criteria Enforcement:
#   If a promise has acceptance_criteria, ALL must have status "met" before
#   verification succeeds. Use cs-promise --meet to submit evidence per criterion.
#   Legacy promises (no acceptance_criteria) require --proof for verification.
#
# After verification, the promise is moved to history.
#
# Environment:
#   CLAUDE_SESSION_ID - Current session identifier (set via cs-init)

set -e

STATE_DIR="${CLAUDE_PROJECT_DIR:-$(pwd)}/.claude/completion-state"
PROMISES_DIR="$STATE_DIR/promises"
HISTORY_DIR="$STATE_DIR/history"

# Require session ID
require_session_id() {
    if [ -z "$CLAUDE_SESSION_ID" ]; then
        echo "Error: CLAUDE_SESSION_ID not set. Run: eval \"\$(cs-init)\"" >&2
        exit 1
    fi
}

# Get current timestamp
get_timestamp() {
    python3 -c 'import datetime; print(datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%dT%H:%M:%SZ"))'
}

# Parse arguments
MODE=""
PROMISE_ID=""
PROOF=""
VERIFY_TYPE="manual"
CHECK_MODE=false
VERBOSE=false
SKIP_VALIDATION_CHECK=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --promise)
            MODE="verify"
            PROMISE_ID="$2"
            shift 2
            ;;
        --proof)
            PROOF="$2"
            shift 2
            ;;
        --type)
            VERIFY_TYPE="$2"
            shift 2
            ;;
        --check)
            CHECK_MODE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --task-id|--task_id)
            TASK_ID="$2"
            shift 2
            ;;
        --skip-validation-check)
            SKIP_VALIDATION_CHECK=true
            shift
            ;;
        --help)
            echo "cs-verify - Verify completion promises"
            echo ""
            echo "Usage:"
            echo "  cs-verify --promise <id>                      Verify (all ACs must be met)"
            echo "  cs-verify --promise <id> --proof \"Summary\"    Verify with optional summary note"
            echo "  cs-verify --promise <id> --type test          Verify with verification type"
            echo "  cs-verify --check                             Check if session can end"
            echo "  cs-verify --check --verbose                   Detailed check with per-AC detail"
            echo ""
            echo "Options:"
            echo "  --promise <id>   Promise ID to verify"
            echo "  --proof <text>   Optional summary note (required for legacy promises without ACs)"
            echo "  --type <type>    Verification type: test, browser, api, manual (default: manual)"
            echo "  --task-id <id>   Also add comment to beads task (atomic update)"
            echo "  --check          Evaluate if session can end (for StopHook)"
            echo "  --verbose        Show detailed output"
            echo "  --skip-validation-check  Skip Gate 2 validation response enforcement"
            echo ""
            echo "Acceptance Criteria:"
            echo "  If a promise has acceptance_criteria, ALL must have status \"met\"."
            echo "  Submit evidence per criterion: cs-promise --meet <id> --ac-id AC-X --evidence \"...\""
            echo "  Legacy promises (no acceptance_criteria) require --proof for verification."
            echo ""
            echo "Exit codes for --check:"
            echo "  0  Session can end (all owned promises verified)"
            echo "  2  Session cannot end (unverified promises remain)"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Run 'cs-verify --help' for usage." >&2
            exit 1
            ;;
    esac
done

# Ensure directories exist
mkdir -p "$PROMISES_DIR"
mkdir -p "$HISTORY_DIR"

# Add comment to beads task if task_id provided
add_beads_comment() {
    local task_id="$1"
    local comment="$2"

    if [ -z "$task_id" ]; then
        return 0
    fi

    # Use bd comment to add the verification evidence
    cd "${CLAUDE_PROJECT_DIR:-$(pwd)}" && cd .. && \
        bd comment add "$task_id" "$comment" 2>/dev/null || {
            echo "Warning: Could not add comment to beads task $task_id" >&2
        }
}

# Handle --check mode (for StopHook)
if [ "$CHECK_MODE" = true ]; then
    require_session_id

    # Find all promises owned by this session
    MY_PROMISES=()
    IN_PROGRESS_COUNT=0
    PENDING_COUNT=0

    if [ -d "$PROMISES_DIR" ] && [ -n "$(ls -A "$PROMISES_DIR" 2>/dev/null)" ]; then
        for f in "$PROMISES_DIR"/*.json; do
            [ -f "$f" ] || continue
            OWNER=$(jq -r '.ownership.owned_by // "null"' "$f")
            if [ "$OWNER" = "$CLAUDE_SESSION_ID" ]; then
                ID=$(jq -r '.id' "$f")
                STATUS=$(jq -r '.status' "$f")
                SUMMARY=$(jq -r '.summary' "$f" | head -c 50)
                MY_PROMISES+=("$ID:$STATUS:$SUMMARY")

                if [ "$STATUS" = "in_progress" ]; then
                    IN_PROGRESS_COUNT=$((IN_PROGRESS_COUNT + 1))
                elif [ "$STATUS" = "pending" ]; then
                    PENDING_COUNT=$((PENDING_COUNT + 1))
                fi
            fi
        done
    fi

    # Check for orphaned in_progress promises (warn but don't block)
    ORPHAN_COUNT=0
    if [ -d "$PROMISES_DIR" ] && [ -n "$(ls -A "$PROMISES_DIR" 2>/dev/null)" ]; then
        for f in "$PROMISES_DIR"/*.json; do
            [ -f "$f" ] || continue
            OWNER=$(jq -r '.ownership.owned_by // "null"' "$f")
            STATUS=$(jq -r '.status' "$f")
            if [ "$OWNER" = "null" ] && [ "$STATUS" = "in_progress" ]; then
                ORPHAN_COUNT=$((ORPHAN_COUNT + 1))
                if [ "$VERBOSE" = true ]; then
                    ID=$(jq -r '.id' "$f")
                    SUMMARY=$(jq -r '.summary' "$f" | head -c 50)
                    echo "WARNING: Orphaned in_progress promise: $ID" >&2
                    echo "  \"$SUMMARY...\"" >&2
                fi
            fi
        done
    fi

    # No owned promises = can exit
    if [ ${#MY_PROMISES[@]} -eq 0 ]; then
        if [ "$VERBOSE" = true ]; then
            echo "No promises owned by this session."
        fi
        if [ $ORPHAN_COUNT -gt 0 ]; then
            echo "WARNING: $ORPHAN_COUNT orphaned in_progress promise(s) detected." >&2
            echo "Run 'cs-promise --list' to see them." >&2
        fi
        exit 0
    fi

    # All owned promises are verified/cancelled = can exit
    if [ $IN_PROGRESS_COUNT -eq 0 ] && [ $PENDING_COUNT -eq 0 ]; then
        if [ "$VERBOSE" = true ]; then
            echo "All owned promises are complete."
        fi
        exit 0
    fi

    # Have unverified promises - block exit
    echo "COMPLETION CRITERIA NOT MET"
    echo ""
    echo "Session: $CLAUDE_SESSION_ID"
    echo ""

    # Track first unmet criterion for NEXT ACTION hint
    FIRST_UNMET_PROMISE=""
    FIRST_UNMET_AC_ID=""

    if [ $IN_PROGRESS_COUNT -gt 0 ]; then
        echo "IN_PROGRESS PROMISES ($IN_PROGRESS_COUNT):"
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "in_progress" ]; then
                PFILE="$PROMISES_DIR/$ID.json"
                echo "  $ID: \"$SUMMARY...\""

                # Show per-criterion detail if acceptance_criteria exist
                if [ -f "$PFILE" ]; then
                    P_HAS_AC=$(jq 'has("acceptance_criteria") and (.acceptance_criteria | length > 0)' "$PFILE")
                    if [ "$P_HAS_AC" = "true" ]; then
                        P_TOTAL=$(jq '.acceptance_criteria | length' "$PFILE")
                        P_MET=$(jq '[.acceptance_criteria[] | select(.status == "met")] | length' "$PFILE")
                        # Show each criterion with status
                        while IFS=$'\t' read -r AC_STATUS AC_ID AC_DESC; do
                            if [ "$AC_STATUS" = "met" ]; then
                                echo "    [MET]     $AC_ID: $AC_DESC"
                            else
                                echo "    [PENDING] $AC_ID: $AC_DESC"
                                # Track first unmet for NEXT ACTION
                                if [ -z "$FIRST_UNMET_PROMISE" ]; then
                                    FIRST_UNMET_PROMISE="$ID"
                                    FIRST_UNMET_AC_ID="$AC_ID"
                                fi
                            fi
                        done < <(jq -r '.acceptance_criteria[] | [.status, .id, .description] | @tsv' "$PFILE")
                        echo "    Progress: $P_MET/$P_TOTAL criteria met"
                    fi
                fi
            fi
        done
        echo ""
    fi

    if [ $PENDING_COUNT -gt 0 ]; then
        echo "PENDING PROMISES ($PENDING_COUNT):"
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "pending" ]; then
                echo "  $ID: \"$SUMMARY...\""
            fi
        done
        echo ""
    fi

    echo "NEXT ACTION:"
    if [ -n "$FIRST_UNMET_PROMISE" ]; then
        # Has unmet acceptance criteria — point to cs-promise --meet
        echo "  Submit evidence: cs-promise --meet $FIRST_UNMET_PROMISE --ac-id $FIRST_UNMET_AC_ID --evidence \"...\" --type test"
    else
        # No AC detail available — fall back to original hint
        for entry in "${MY_PROMISES[@]}"; do
            IFS=':' read -r ID STATUS SUMMARY <<< "$entry"
            if [ "$STATUS" = "in_progress" ]; then
                echo "  Complete and verify: cs-verify --promise $ID --proof \"...\""
                break
            elif [ "$STATUS" = "pending" ]; then
                echo "  Start work: cs-promise --start $ID"
                break
            fi
        done
    fi

    if [ $ORPHAN_COUNT -gt 0 ]; then
        echo ""
        echo "WARNING: $ORPHAN_COUNT orphaned in_progress promise(s) detected."
        echo "Consider adopting or investigating crashed sessions."
    fi

    # Exit 2 to block stop
    exit 2
fi

# Gate 2: Check that validation responses exist and passed for all ACs
check_validation_responses() {
    local promise_id="$1"
    local promise_file="$2"

    local validations_dir="$STATE_DIR/validations/$promise_id"

    # Skip for legacy promises (no ACs)
    local has_ac
    has_ac=$(jq 'has("acceptance_criteria") and (.acceptance_criteria | length > 0)' "$promise_file")
    if [ "$has_ac" != "true" ]; then
        echo "Gate 2: Skipped (legacy promise without acceptance criteria)"
        return 0
    fi

    # Check each AC for a validation response
    local all_passed=true
    local missing_count=0
    local fail_count=0

    while IFS=$'\t' read -r ac_id ac_desc; do
        local validation_file="$validations_dir/${ac_id}-validation.json"

        if [ ! -f "$validation_file" ]; then
            echo "Gate 2 BLOCKED: Missing validation for $ac_id" >&2
            echo "  Criterion: $ac_desc" >&2
            echo "  Expected:  $validation_file" >&2
            echo "" >&2
            missing_count=$((missing_count + 1))
            all_passed=false
            continue
        fi

        local verdict
        verdict=$(jq -r '.verdict' "$validation_file")

        case "$verdict" in
            PASS|PARTIAL)
                # PASS and PARTIAL are acceptable for Gate 2
                ;;
            FAIL)
                echo "Gate 2 BLOCKED: Validation FAILED for $ac_id" >&2
                echo "  Criterion: $ac_desc" >&2
                local reasoning
                reasoning=$(jq -r '.reasoning // "No reasoning provided"' "$validation_file")
                echo "  Reasoning: $reasoning" >&2
                # Show failed criteria details
                jq -r '.criteria_results[]? | select(.status == "FAIL") | "  - [\(.criterion_id // "?")] \(.evidence // .reason // "No details")"' "$validation_file" >&2
                echo "" >&2
                fail_count=$((fail_count + 1))
                all_passed=false
                ;;
            BLOCKED)
                echo "Gate 2 BLOCKED: Validation BLOCKED for $ac_id" >&2
                echo "  Criterion: $ac_desc" >&2
                local block_reason
                block_reason=$(jq -r '.reasoning // "No reasoning provided"' "$validation_file")
                echo "  Reason: $block_reason" >&2
                echo "" >&2
                all_passed=false
                ;;
            *)
                echo "Gate 2 BLOCKED: Unknown verdict '$verdict' for $ac_id" >&2
                all_passed=false
                ;;
        esac
    done < <(jq -r '.acceptance_criteria[] | [.id, .description] | @tsv' "$promise_file")

    if [ "$all_passed" != "true" ]; then
        if [ $missing_count -gt 0 ]; then
            echo "ACTION: Dispatch s3-validator teammates to validate before running cs-verify." >&2
            echo "  Store results with: cs-store-validation --promise $promise_id --ac-id <AC-X> --response '<json>'" >&2
        fi
        if [ $fail_count -gt 0 ]; then
            echo "ACTION: Address validation failures and re-run validators before verifying." >&2
        fi
        return 1
    fi

    return 0
}

# Handle verification mode
if [ "$MODE" != "verify" ]; then
    echo "Error: Must specify --promise or --check" >&2
    exit 1
fi

require_session_id

if [ -z "$PROMISE_ID" ]; then
    echo "Error: --promise requires an ID" >&2
    exit 1
fi

# Validate verification type
case $VERIFY_TYPE in
    test|browser|api|manual) ;;
    *)
        echo "Error: Invalid verification type: $VERIFY_TYPE" >&2
        echo "Valid types: test, browser, api, manual" >&2
        exit 1
        ;;
esac

PROMISE_FILE="$PROMISES_DIR/$PROMISE_ID.json"
if [ ! -f "$PROMISE_FILE" ]; then
    echo "Error: Promise not found: $PROMISE_ID" >&2
    exit 1
fi

# Check ownership
OWNER=$(jq -r '.ownership.owned_by // "null"' "$PROMISE_FILE")
if [ "$OWNER" != "$CLAUDE_SESSION_ID" ]; then
    echo "Error: You don't own this promise. Current owner: $OWNER" >&2
    echo "Use 'cs-promise --adopt $PROMISE_ID' to claim it first." >&2
    exit 1
fi

# Check current status
CURRENT_STATUS=$(jq -r '.status' "$PROMISE_FILE")
if [ "$CURRENT_STATUS" = "verified" ]; then
    echo "Error: Promise is already verified." >&2
    exit 1
fi

if [ "$CURRENT_STATUS" = "cancelled" ]; then
    echo "Error: Cannot verify a cancelled promise." >&2
    exit 1
fi

if [ "$CURRENT_STATUS" = "pending" ]; then
    echo "Note: Promise was pending. Setting to in_progress before verifying." >&2
fi

# Check if promise has acceptance_criteria
HAS_AC=$(jq 'has("acceptance_criteria") and (.acceptance_criteria | length > 0)' "$PROMISE_FILE")

if [ "$HAS_AC" = "true" ]; then
    # Promise has acceptance criteria - check all are met
    TOTAL_AC=$(jq '.acceptance_criteria | length' "$PROMISE_FILE")
    MET_AC=$(jq '[.acceptance_criteria[] | select(.status == "met")] | length' "$PROMISE_FILE")
    PENDING_AC=$((TOTAL_AC - MET_AC))

    if [ $PENDING_AC -gt 0 ]; then
        echo "Error: Cannot verify $PROMISE_ID — $PENDING_AC of $TOTAL_AC criteria still pending:" >&2
        echo "" >&2
        # List unmet criteria
        jq -r '.acceptance_criteria[] | select(.status != "met") | "  [PENDING] \(.id): \(.description)"' "$PROMISE_FILE" >&2
        echo "" >&2
        # Show hint for first unmet criterion
        FIRST_UNMET_ID=$(jq -r '[.acceptance_criteria[] | select(.status != "met")][0].id' "$PROMISE_FILE")
        echo "Submit evidence for each criterion first:" >&2
        echo "  cs-promise --meet $PROMISE_ID --ac-id $FIRST_UNMET_ID --evidence \"...\" --type test" >&2
        exit 1
    fi
    # All ACs met — --proof is optional (stored as summary note if provided)

    # Gate 2: Validation response enforcement
    if [ "$SKIP_VALIDATION_CHECK" != "true" ]; then
        if ! check_validation_responses "$PROMISE_ID" "$PROMISE_FILE"; then
            exit 1
        fi
        echo "Gate 2: All validation responses verified (PASS)"
    else
        echo "WARNING: Skipping Gate 2 validation check (--skip-validation-check)" >&2
    fi
else
    # Legacy promise (no acceptance_criteria) — --proof is required
    if [ -z "$PROOF" ]; then
        echo "Error: --proof is required for legacy promises without acceptance criteria" >&2
        exit 1
    fi
fi

# Gate 3: Agent SDK verification (MANDATORY — cannot be bypassed)
{
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    LLM_SCRIPT="$SCRIPT_DIR/cs-verify-llm.py"

    if [ ! -f "$LLM_SCRIPT" ]; then
        echo "ERROR: Gate 3 independent verification is mandatory." >&2
        echo "The Agent SDK verification script was not found at $LLM_SCRIPT" >&2
        echo "" >&2
        echo "System 3 must spawn a validation-test-agent teammate for independent verification:" >&2
        echo "" >&2
        echo "  Task(" >&2
        echo "      subagent_type=\"validation-test-agent\"," >&2
        echo "      team_name=\"s3-live\"," >&2
        echo "      name=\"s3-gate3-validator\"," >&2
        echo "      model=\"sonnet\"," >&2
        echo "      prompt=\"--mode=e2e --promise=\$PROMISE_ID (see .claude/agents/validation-test-agent.md)\"" >&2
        echo "  )" >&2
        echo "" >&2
        echo "Once the validator confirms all ACs pass, re-run cs-verify." >&2
        exit 1
    else
        echo "Running Gate 3 Agent SDK verification..."

        # Extract criteria JSON from promise file
        CRITERIA_JSON=$(jq -c '.acceptance_criteria' "$PROMISE_FILE")

        # Call Agent SDK verification
        LLM_RESULT=$("$LLM_SCRIPT" \
            --summary "$SUMMARY" \
            --criteria "$CRITERIA_JSON" \
            --promise-id "$PROMISE_ID" \
            ${PROOF:+--proof "$PROOF"} 2>/dev/null) || true

        if [ -n "$LLM_RESULT" ]; then
            LLM_VERDICT=$(echo "$LLM_RESULT" | jq -r '.verdict // "WARN"')
            LLM_REASONING=$(echo "$LLM_RESULT" | jq -r '.reasoning // "No response"')
            LLM_CONFIDENCE=$(echo "$LLM_RESULT" | jq -r '.confidence // "N/A"')
            LLM_COST=$(echo "$LLM_RESULT" | jq -r '.cost_estimate_usd // "N/A"')

            if [ "$LLM_VERDICT" = "FAIL" ]; then
                echo "" >&2
                echo "GATE 3 FAILED: Agent SDK verification rejected evidence" >&2
                echo "Reasoning: $LLM_REASONING" >&2
                echo "Confidence: $LLM_CONFIDENCE" >&2
                echo "" >&2
                echo "The codebase-aware judge could not verify the claims." >&2
                echo "Address the issues above and try again." >&2
                exit 1
            elif [ "$LLM_VERDICT" = "WARN" ]; then
                echo "WARNING: Gate 3 Agent SDK unavailable. $LLM_REASONING" >&2
                echo "Proceeding with Gates 1-2 only (graceful degradation)." >&2
            else
                echo "Gate 3: Agent SDK verification PASS (confidence: $LLM_CONFIDENCE, cost: \$$LLM_COST)"
            fi
        else
            echo "WARNING: Gate 3 Agent SDK returned empty result." >&2
            echo "Proceeding with Gates 1-2 only (graceful degradation)." >&2
        fi
    fi
}

TIMESTAMP=$(get_timestamp)
SUMMARY=$(jq -r '.summary' "$PROMISE_FILE")

# Update promise with verification
if [ -n "$PROOF" ]; then
    jq --arg ts "$TIMESTAMP" \
       --arg session "$CLAUDE_SESSION_ID" \
       --arg type "$VERIFY_TYPE" \
       --arg proof "$PROOF" '
        .status = "verified" |
        .verification.verified_at = $ts |
        .verification.verified_by = $session |
        .verification.type = $type |
        .verification.proof = $proof
    ' "$PROMISE_FILE" > "$PROMISE_FILE.tmp" && mv "$PROMISE_FILE.tmp" "$PROMISE_FILE"
else
    jq --arg ts "$TIMESTAMP" \
       --arg session "$CLAUDE_SESSION_ID" \
       --arg type "$VERIFY_TYPE" '
        .status = "verified" |
        .verification.verified_at = $ts |
        .verification.verified_by = $session |
        .verification.type = $type
    ' "$PROMISE_FILE" > "$PROMISE_FILE.tmp" && mv "$PROMISE_FILE.tmp" "$PROMISE_FILE"
fi

# Move to history
mv "$PROMISE_FILE" "$HISTORY_DIR/"

echo "VERIFIED: $PROMISE_ID"
echo ""
echo "Summary: $SUMMARY"
echo "Type: $VERIFY_TYPE"
if [ -n "$PROOF" ]; then
    echo "Proof: $PROOF"
fi
if [ "$HAS_AC" = "true" ]; then
    echo "Acceptance Criteria: $TOTAL_AC/$TOTAL_AC met"
fi
echo "Verified by: $CLAUDE_SESSION_ID"
echo "Verified at: $TIMESTAMP"
echo ""
echo "Promise moved to history."

# Add comment to beads task if --task-id was provided
if [ -n "$TASK_ID" ]; then
    COMMENT="[cs-verify] Type: $VERIFY_TYPE | Session: $CLAUDE_SESSION_ID | Time: $TIMESTAMP"
    if [ -n "$PROOF" ]; then
        COMMENT="$COMMENT | Proof: $PROOF"
    fi
    if [ "$HAS_AC" = "true" ]; then
        COMMENT="$COMMENT | ACs: $TOTAL_AC/$TOTAL_AC met"
    fi
    add_beads_comment "$TASK_ID" "$COMMENT"
    echo ""
    echo "Added verification comment to beads task: $TASK_ID"
fi
