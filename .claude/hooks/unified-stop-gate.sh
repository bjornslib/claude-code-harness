#!/bin/bash
# unified-stop-gate.sh
# Simplified stop hook that uses existing cs-* scripts for promise checking
#
# Architecture:
#   1. cs-verify --check: Completion promise validation (exit 0=ok, 2=block)
#   2. OrchestratorGuidanceChecker: Blocker escalation (orch-* sessions only)
#   3. bd ready: Momentum check for available work
#   4. Stop attempt bypass: Allow through after 2 blocked attempts
#
# Removed (v2):
#   - CompletionPromiseChecker (replaced by cs-verify --check)
#   - GoalValidator (redundant when promises are used properly)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
CS_VERIFY="$PROJECT_ROOT/.claude/scripts/completion-state/cs-verify"

# Read JSON from stdin (Claude Code passes context)
INPUT=$(cat)

SESSION_ID="${CLAUDE_SESSION_ID:-}"

# --- Helper functions ---

get_stop_marker_path() {
    local sid="${1:-fallback}"
    echo "/tmp/claude-stop-momentum-${sid}"
}

get_stop_attempt_count() {
    local sid="${1:-fallback-$(date +%Y%m%d)-$$}"
    local marker
    marker=$(get_stop_marker_path "$sid")
    if [ -f "$marker" ]; then
        # Check file age using find (avoids python3 startup)
        local old_marker
        old_marker=$(find "$marker" -mmin +5 2>/dev/null)
        if [ -z "$old_marker" ]; then
            # File is less than 5 minutes old
            cat "$marker" 2>/dev/null || echo "1"
            return
        fi
        rm -f "$marker"
    fi
    echo "0"
}

mark_stop_attempt() {
    local sid="${1:-fallback}"
    local marker
    marker=$(get_stop_marker_path "$sid")
    local current
    current=$(get_stop_attempt_count "$sid")
    echo $((current + 1)) > "$marker"
}

output_json() {
    local decision="$1"
    local key="$2"  # unused, kept for compatibility
    local message="$3"
    # Use jq for fast JSON construction (avoids python3 startup overhead)
    if [ "$decision" = "approve" ]; then
        jq -n --arg msg "$message" '{"decision": "approve", "systemMessage": $msg}'
    else
        jq -n --arg msg "$message" '{"decision": "block", "reason": $msg}'
    fi
}

# --- Step 1: Completion Promise Check (via cs-verify) ---
# REQUIRES CLAUDE_SESSION_ID - if not set, skip promise checking entirely

PROMISE_PASSED=true
PROMISE_MESSAGE=""

if [ -z "$SESSION_ID" ]; then
    # No session ID = no promise tracking = always OK to stop
    PROMISE_MESSAGE="No CLAUDE_SESSION_ID set - OK to stop"
elif [ ! -x "$CS_VERIFY" ]; then
    PROMISE_MESSAGE="cs-verify not found - promise check skipped"
else
    # Run cs-verify and capture exit code properly
    CS_EXIT=0
    CS_OUTPUT=$("$CS_VERIFY" --check --verbose 2>&1) || CS_EXIT=$?

    # cs-verify returns: 0=can stop, 2=cannot stop, 1=error
    if [ "$CS_EXIT" -eq 2 ]; then
        PROMISE_PASSED=false
        PROMISE_MESSAGE="$CS_OUTPUT"
    elif [ "$CS_EXIT" -eq 0 ]; then
        PROMISE_MESSAGE="$CS_OUTPUT"
    else
        # Error case - allow stop but note the error
        PROMISE_MESSAGE="Promise check error (allowing stop): $CS_OUTPUT"
    fi
fi

# If promises block, output immediately
if [ "$PROMISE_PASSED" = false ]; then
    output_json "block" "reason" "$(cat <<EOF
ðŸš« COMPLETION CRITERIA NOT MET

${PROMISE_MESSAGE}

To proceed:
1. Complete or verify your promises: cs-promise --mine
2. Or adopt/cancel orphaned promises
3. Session ID is auto-generated by ccsystem3
EOF
)"
    exit 0
fi

# --- Step 2: Orchestrator Guidance Check (orch-* sessions only) ---

if [[ "$SESSION_ID" == orch-* ]]; then
    # Use gtimeout on macOS (GNU coreutils), fallback to timeout on Linux
    TIMEOUT_CMD="timeout"
    if command -v gtimeout &> /dev/null; then
        TIMEOUT_CMD="gtimeout"
    fi

    ORCH_RESULT=$(cd "$PROJECT_ROOT" && $TIMEOUT_CMD 5s python3 << 'ORCH_CHECK'
import json
import sys
import os

sys.path.insert(0, os.path.join(os.environ.get('CLAUDE_PROJECT_DIR', os.getcwd()), '.claude', 'hooks'))

try:
    from unified_stop_gate.checkers import OrchestratorGuidanceChecker
    from unified_stop_gate.config import EnvironmentConfig, PathResolver

    config = EnvironmentConfig.from_env()
    paths = PathResolver(config=config)
    checker = OrchestratorGuidanceChecker(config, paths)
    result = checker.check()

    if not result.passed:
        print(json.dumps({"passed": False, "message": result.message}))
    else:
        print(json.dumps({"passed": True, "message": result.message}))
except Exception as e:
    print(json.dumps({"passed": True, "message": f"Orchestrator check error: {e}"}))
ORCH_CHECK
)
    TIMEOUT_EXIT=$?
    if [ $TIMEOUT_EXIT -eq 124 ]; then
        echo "âš ï¸  Orchestrator check timed out (5s), allowing stop" >&2
        ORCH_RESULT='{"passed": true, "message": "Check timed out, allowing stop"}'
    fi

    ORCH_PASSED=$(echo "$ORCH_RESULT" | jq -r '.passed // true')
    if [ "$ORCH_PASSED" = "false" ]; then
        ORCH_MSG=$(echo "$ORCH_RESULT" | jq -r '.message // ""')
        output_json "block" "reason" "$ORCH_MSG"
        exit 0
    fi
fi

# --- Step 3: Momentum Check (bd ready) ---
# Call bd ready ONCE and cache the result
# Skip entirely if no .beads/ directory exists (saves ~0.5s)

READY_WORK=""
HAS_HIGH_PRIORITY=false

if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    READY_WORK=$(bd ready --limit=5 2>/dev/null) || READY_WORK=""
    if echo "$READY_WORK" | grep -qE 'P[012]\]'; then
        HAS_HIGH_PRIORITY=true
    fi
fi

if [ "$HAS_HIGH_PRIORITY" = true ]; then
    # Check stop attempt bypass (allow after 2 blocked attempts)
    ATTEMPT_COUNT=$(get_stop_attempt_count "$SESSION_ID")

    if [ "$ATTEMPT_COUNT" -ge 2 ]; then
        # Third+ attempt - allow through with reminder
        output_json "approve" "systemMessage" "$(cat <<EOF
âœ… ${PROMISE_MESSAGE}

(Momentum check bypassed after 2 blocked attempts)
EOF
)"
    else
        # Block and encourage continuation
        ATTEMPT_NUM=$((ATTEMPT_COUNT + 1))
        mark_stop_attempt "$SESSION_ID"
        REMAINING=$((3 - ATTEMPT_NUM))

        output_json "block" "reason" "$(cat <<EOF
## ðŸš€ High-Priority Work Available - Continue Working!

\`\`\`
${READY_WORK}
\`\`\`

**P0-P2 work is unblocked.** You should continue autonomously.

Actions:
1. Pick a task from the list above
2. Add todos and proceed with implementation
3. Only stop if genuinely blocked or user input required

IMPORTANT: If you are seriously blocked from progressing without user input, submit user option questions so that they can provide you with the necessary feedback.

*Attempt ${ATTEMPT_NUM}/2. Stop ${REMAINING} more time(s) to bypass.*
EOF
)"
    fi
else
    # No high-priority work or no beads - allow stop with context
    MSG_PARTS="âœ… ${PROMISE_MESSAGE}"

    if [ -n "$READY_WORK" ]; then
        MSG_PARTS="$(cat <<EOF
${MSG_PARTS}

## ðŸš€ Momentum Check: Unblocked Work Available

\`\`\`
${READY_WORK}
\`\`\`

**Decision Framework:**
- **Continue** if: P0-P2 beads ready, clear implementation path
- **Stop** if: Only P3-P4 work, blocked on external factors, user feedback required
IMPORTANT: If you are seriously blocked from progressing without user input, submit user option questions so that they can provide you with the necessary feedback
If continuing: Add specific todos and proceed autonomously.
EOF
)"
    fi

    output_json "approve" "systemMessage" "$MSG_PARTS"
fi
