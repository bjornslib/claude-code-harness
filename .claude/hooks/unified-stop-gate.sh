#!/bin/bash
# unified-stop-gate.sh - UNIFIED stop hook (only hook that runs)
#
# Architecture:
#   1. Completion Promise Check: BLOCKS if open promises owned by this session
#   2. Orchestrator Guidance: BLOCKS orch-* sessions with unescalated blockers
#   3. Beads Sync Check: BLOCKS if .beads/ has uncommitted changes
#   4. Work Exhaustion Check: BLOCKS if work available but no sensible continuation
#   5. System 3 Judge: BLOCKS system3-* sessions if Haiku judge says continue
#   6. Work Available: INFORMS about priority-ordered work (NEVER blocks)
#
# Changes from v2:
#   - Removed momentum check blocking (user intent: inform, don't block)
#   - Removed stop attempt bypass logic (no longer needed)
#   - Added beads sync enforcement
#   - Added todo continuation enforcement
#   - Fixed priority ordering (P0 â†’ P1 â†’ P2...)
#   - Fixed contradictory output ("No open issues" check)
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
CS_VERIFY="$PROJECT_ROOT/.claude/scripts/completion-state/cs-verify"

# Read JSON from stdin (Claude Code passes context)
INPUT=$(cat)

# Export for Python subprocesses (needed by SessionInfo.from_hook_input)
export CLAUDE_HOOK_INPUT="$INPUT"

SESSION_ID="${CLAUDE_SESSION_ID:-}"

# --- Helper function ---

output_json() {
    local decision="$1"
    local key="$2"  # unused, kept for compatibility
    local message="$3"
    # Use jq for fast JSON construction (avoids python3 startup overhead)
    if [ "$decision" = "approve" ]; then
        jq -n --arg msg "$message" '{"decision": "approve", "systemMessage": $msg}'
    else
        jq -n --arg msg "$message" '{"decision": "block", "reason": $msg}'
    fi
}

# --- Step 1: Completion Promise Check (via cs-verify) ---
# REQUIRES CLAUDE_SESSION_ID - if not set, skip promise checking entirely

PROMISE_PASSED=true
PROMISE_MESSAGE=""

if [ -z "$SESSION_ID" ]; then
    # No session ID = no promise tracking = always OK to stop
    PROMISE_MESSAGE="No CLAUDE_SESSION_ID set - OK to stop"
elif [ ! -x "$CS_VERIFY" ]; then
    PROMISE_MESSAGE="cs-verify not found - promise check skipped"
else
    # Run cs-verify and capture exit code properly
    CS_EXIT=0
    CS_OUTPUT=$("$CS_VERIFY" --check --verbose 2>&1) || CS_EXIT=$?

    # cs-verify returns: 0=can stop, 2=cannot stop, 1=error
    if [ "$CS_EXIT" -eq 2 ]; then
        PROMISE_PASSED=false
        PROMISE_MESSAGE="$CS_OUTPUT"
    elif [ "$CS_EXIT" -eq 0 ]; then
        PROMISE_MESSAGE="$CS_OUTPUT"
    else
        # Error case - allow stop but note the error
        PROMISE_MESSAGE="Promise check error (allowing stop): $CS_OUTPUT"
    fi
fi

# If promises block, output immediately
if [ "$PROMISE_PASSED" = false ]; then
    output_json "block" "reason" "ðŸš« COMPLETION CRITERIA NOT MET

${PROMISE_MESSAGE}

To proceed:
1. Complete or verify your promises: cs-promise --mine
2. Or adopt/cancel orphaned promises
3. Session ID is auto-generated by ccsystem3"
    exit 0
fi

# --- Step 2: Orchestrator Guidance Check (orch-* sessions only) ---

if [[ "$SESSION_ID" == orch-* ]]; then
    # Use gtimeout on macOS (GNU coreutils), fallback to timeout on Linux
    TIMEOUT_CMD="timeout"
    if command -v gtimeout &> /dev/null; then
        TIMEOUT_CMD="gtimeout"
    fi

    ORCH_EXIT=0
    ORCH_RESULT=$(cd "$PROJECT_ROOT" && $TIMEOUT_CMD 20s python3 << 'ORCH_CHECK'
import json
import sys
import os

sys.path.insert(0, os.path.join(os.environ.get('CLAUDE_PROJECT_DIR', os.getcwd()), '.claude', 'hooks'))

try:
    from unified_stop_gate.checkers import OrchestratorGuidanceChecker
    from unified_stop_gate.config import EnvironmentConfig, PathResolver

    config = EnvironmentConfig.from_env()
    paths = PathResolver(config=config)
    checker = OrchestratorGuidanceChecker(config, paths)
    result = checker.check()

    if not result.passed:
        print(json.dumps({"passed": False, "message": result.message}))
    else:
        print(json.dumps({"passed": True, "message": result.message}))
except Exception as e:
    print(json.dumps({"passed": True, "message": f"Orchestrator check error: {e}"}))
ORCH_CHECK
) || ORCH_EXIT=$?
    if [ $ORCH_EXIT -eq 124 ]; then
        echo "âš ï¸  Orchestrator check timed out (20s), allowing stop" >&2
        ORCH_RESULT='{"passed": true, "message": "Check timed out, allowing stop"}'
    elif [ $ORCH_EXIT -ne 0 ] && [ -z "$ORCH_RESULT" ]; then
        echo "âš ï¸  Orchestrator check failed (exit $ORCH_EXIT), allowing stop" >&2
        ORCH_RESULT='{"passed": true, "message": "Check failed (fail-open), allowing stop"}'
    fi

    # NOTE: jq's // operator treats false same as null, so '.passed // true' ALWAYS returns true.
    # Use explicit null check to preserve false values.
    ORCH_PASSED=$(printf '%s\n' "$ORCH_RESULT" | jq -r 'if .passed == null then "true" else (.passed | tostring) end')
    if [ "$ORCH_PASSED" = "false" ]; then
        ORCH_MSG=$(printf '%s\n' "$ORCH_RESULT" | jq -r '.message // ""')
        output_json "block" "reason" "$ORCH_MSG"
        exit 0
    fi
fi

# --- Step 3: Beads Sync Check ---
# Ensure beads changes are committed to git

BEADS_NEEDS_SYNC=false

if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    # Check if beads directory has uncommitted changes
    if git -C "$PROJECT_ROOT" status --porcelain .beads/ 2>/dev/null | grep -q .; then
        BEADS_NEEDS_SYNC=true
    fi
fi

if [ "$BEADS_NEEDS_SYNC" = true ]; then
    output_json "block" "reason" "ðŸš« BEADS SYNC REQUIRED

Beads directory has uncommitted changes. Run 'bd sync' before stopping.

Beads changes must be committed to git before stopping to prevent loss of work tracking.

To proceed:
1. Run: bd sync
2. Try stopping again"
    exit 0
fi

# --- Step 4: Work Exhaustion Check (replaces simple Todo Continuation) ---
# Three-layer evaluation: promises + beads + task sensibility
# Produces WORK_STATE_SUMMARY for Step 5 (System 3 Judge)

WORK_EXHAUSTION_PASSED=true
WORK_STATE_SUMMARY=""

TASK_LIST_ID="${CLAUDE_CODE_TASK_LIST_ID:-}"

if [ -n "$TASK_LIST_ID" ]; then
    # Use gtimeout on macOS (GNU coreutils), fallback to timeout on Linux
    TIMEOUT_CMD="timeout"
    if command -v gtimeout &> /dev/null; then
        TIMEOUT_CMD="gtimeout"
    fi

    STEP4_EXIT=0
    STEP4_RESULT=$($TIMEOUT_CMD 20s python3 << 'WORK_CHECK'
import json
import sys
import os

sys.path.insert(0, os.path.join(os.environ.get('CLAUDE_PROJECT_DIR', os.getcwd()), '.claude', 'hooks'))

try:
    from unified_stop_gate.work_exhaustion_checker import WorkExhaustionChecker
    from unified_stop_gate.config import EnvironmentConfig

    config = EnvironmentConfig.from_env()
    checker = WorkExhaustionChecker(config)
    result = checker.check()
    work_summary = checker.work_state_summary

    print(json.dumps({
        "passed": result.passed,
        "message": result.message,
        "work_state_summary": work_summary
    }))
except Exception as e:
    print(json.dumps({
        "passed": True,
        "message": f"Work exhaustion check error (fail-open): {e}",
        "work_state_summary": ""
    }))
WORK_CHECK
) || STEP4_EXIT=$?
    if [ $STEP4_EXIT -eq 124 ]; then
        echo "âš ï¸  Work exhaustion check timed out (20s), allowing stop" >&2
        STEP4_RESULT='{"passed": true, "message": "Work exhaustion check timed out, allowing stop", "work_state_summary": ""}'
    elif [ $STEP4_EXIT -ne 0 ] && [ -z "$STEP4_RESULT" ]; then
        echo "âš ï¸  Work exhaustion check failed (exit $STEP4_EXIT), allowing stop" >&2
        STEP4_RESULT='{"passed": true, "message": "Work exhaustion check failed (fail-open), allowing stop", "work_state_summary": ""}'
    fi

    # Parse result (using explicit null check to preserve false values)
    STEP4_PASSED=$(printf '%s\n' "$STEP4_RESULT" | jq -r 'if .passed == null then "true" else (.passed | tostring) end')
    STEP4_MSG=$(printf '%s\n' "$STEP4_RESULT" | jq -r '.message // ""')

    # Extract work state summary for Step 5
    export WORK_STATE_SUMMARY=$(printf '%s\n' "$STEP4_RESULT" | jq -r '.work_state_summary // ""')

    if [ "$STEP4_PASSED" = "false" ]; then
        WORK_EXHAUSTION_PASSED=false
    fi
fi

if [ "$WORK_EXHAUSTION_PASSED" = false ]; then
    output_json "block" "reason" "$STEP4_MSG"
    exit 0
fi

# --- Step 5: Continuation Judge (all sessions with SESSION_ID) ---
# Uses Haiku 4.5 API call to evaluate if session should continue
# Strictness varies: System 3 = strict, Orchestrators = light, Others = light

S3_MSG=""

if [ -n "$SESSION_ID" ]; then
    TIMEOUT_CMD="timeout"
    if command -v gtimeout &> /dev/null; then
        TIMEOUT_CMD="gtimeout"
    fi

    S3_EXIT=0
    S3_RESULT=$($TIMEOUT_CMD 20s python3 << 'S3_CHECK'
import json
import sys
import os

sys.path.insert(0, os.path.join(os.environ.get('CLAUDE_PROJECT_DIR', os.getcwd()), '.claude', 'hooks'))

try:
    from unified_stop_gate.system3_continuation_judge import System3ContinuationJudgeChecker
    from unified_stop_gate.config import EnvironmentConfig
    from unified_stop_gate.checkers import SessionInfo

    hook_input = json.loads(os.environ.get('CLAUDE_HOOK_INPUT', '{}'))
    config = EnvironmentConfig.from_env()
    session = SessionInfo.from_hook_input(hook_input)
    checker = System3ContinuationJudgeChecker(config, session)
    result = checker.check()

    print(json.dumps({"passed": result.passed, "message": result.message}))
except Exception as e:
    print(json.dumps({"passed": True, "message": f"System 3 judge error: {e}"}))
S3_CHECK
) || S3_EXIT=$?
    if [ $S3_EXIT -eq 124 ]; then
        echo "âš ï¸  System 3 judge timed out (20s), allowing stop" >&2
        S3_RESULT='{"passed": true, "message": "Judge timed out, allowing stop"}'
    elif [ $S3_EXIT -ne 0 ] && [ -z "$S3_RESULT" ]; then
        echo "âš ï¸  System 3 judge failed (exit $S3_EXIT), allowing stop" >&2
        S3_RESULT='{"passed": true, "message": "Judge failed (fail-open), allowing stop"}'
    fi

    # NOTE: jq's // operator treats false same as null, so '.passed // true' ALWAYS returns true.
    # Use explicit null check to preserve false values.
    S3_PASSED=$(printf '%s\n' "$S3_RESULT" | jq -r 'if .passed == null then "true" else (.passed | tostring) end')
    # ALWAYS extract message (not just on block)
    S3_MSG=$(printf '%s\n' "$S3_RESULT" | jq -r '.message // ""')

    if [ "$S3_PASSED" = "false" ]; then
        output_json "block" "reason" "$S3_MSG"
        exit 0
    fi
fi

# --- Step 6: Work Available (INFORMATIONAL ONLY - NEVER BLOCKS) ---
# Show priority-ordered work, but always approve

READY_WORK=""

if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    # Get all open tasks, sort by priority (P0 â†’ P1 â†’ P2...), take top 5
    READY_WORK=$(bd list --status=open 2>/dev/null | grep -E '\[P[0-9]\]' | sort -t'[' -k2,2n | head -5) || READY_WORK=""
fi

# Check for impl_complete tasks awaiting S3 validation
IMPL_COMPLETE_WORK=""
if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    IMPL_COMPLETE_WORK=$(bd list --status=impl_complete 2>/dev/null | grep -E '(beads-|bd-)' | head -5) || IMPL_COMPLETE_WORK=""
fi

# Build final message
MSG_PARTS="âœ… ${PROMISE_MESSAGE}"

# Add Step 4 work-state context if available (even when passing)
if [ -n "$STEP4_MSG" ]; then
    MSG_PARTS="${MSG_PARTS}
ðŸ“Š ${STEP4_MSG}"
fi

# Add System 3 judge result if present
if [ -n "$S3_MSG" ]; then
    MSG_PARTS="${MSG_PARTS}
ðŸ§  ${S3_MSG}"
fi

# Only show work section if there's actual work (not just "No open issues")
if [ -n "$READY_WORK" ] && ! echo "$READY_WORK" | grep -q "No open issues"; then
    MSG_PARTS="${MSG_PARTS}

## ðŸš€ Available Work (Priority Order)

\`\`\`
${READY_WORK}
\`\`\`

**Decision Framework:**
- **Continue** if: P0-P2 tasks ready, clear implementation path
- **Stop** if: Only P3-P4 work, blocked on external factors, user feedback required

If continuing: Add specific todos and proceed autonomously."
fi

# Add impl_complete work section if present
if [ -n "$IMPL_COMPLETE_WORK" ]; then
    MSG_PARTS="${MSG_PARTS}

## Awaiting S3 Validation (impl_complete)

\`\`\`
${IMPL_COMPLETE_WORK}
\`\`\`

These tasks have been implemented but not yet validated by System 3's oversight team."
fi

# Always approve (blocking happens earlier or not at all)
output_json "approve" "systemMessage" "$MSG_PARTS"
