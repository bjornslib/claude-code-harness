#!/bin/bash
# unified-stop-gate.sh - UNIFIED stop hook (only hook that runs)
#
# Architecture:
#   1. Completion Promise Check: BLOCKS if open promises owned by this session
#   2. Orchestrator Guidance: BLOCKS orch-* sessions with unescalated blockers
#   3. Beads Sync Check: BLOCKS if .beads/ has uncommitted changes
#   4. Todo Continuation Check: BLOCKS if no continuation todo exists
#   5. Work Available: INFORMS about priority-ordered work (NEVER blocks)
#
# Changes from v2:
#   - Removed momentum check blocking (user intent: inform, don't block)
#   - Removed stop attempt bypass logic (no longer needed)
#   - Added beads sync enforcement
#   - Added todo continuation enforcement
#   - Fixed priority ordering (P0 â†’ P1 â†’ P2...)
#   - Fixed contradictory output ("No open issues" check)
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
CS_VERIFY="$PROJECT_ROOT/.claude/scripts/completion-state/cs-verify"

# Read JSON from stdin (Claude Code passes context)
INPUT=$(cat)

SESSION_ID="${CLAUDE_SESSION_ID:-}"

# --- Helper function ---

output_json() {
    local decision="$1"
    local key="$2"  # unused, kept for compatibility
    local message="$3"
    # Use jq for fast JSON construction (avoids python3 startup overhead)
    if [ "$decision" = "approve" ]; then
        jq -n --arg msg "$message" '{"decision": "approve", "systemMessage": $msg}'
    else
        jq -n --arg msg "$message" '{"decision": "block", "reason": $msg}'
    fi
}

# --- Step 1: Completion Promise Check (via cs-verify) ---
# REQUIRES CLAUDE_SESSION_ID - if not set, skip promise checking entirely

PROMISE_PASSED=true
PROMISE_MESSAGE=""

if [ -z "$SESSION_ID" ]; then
    # No session ID = no promise tracking = always OK to stop
    PROMISE_MESSAGE="No CLAUDE_SESSION_ID set - OK to stop"
elif [ ! -x "$CS_VERIFY" ]; then
    PROMISE_MESSAGE="cs-verify not found - promise check skipped"
else
    # Run cs-verify and capture exit code properly
    CS_EXIT=0
    CS_OUTPUT=$("$CS_VERIFY" --check --verbose 2>&1) || CS_EXIT=$?

    # cs-verify returns: 0=can stop, 2=cannot stop, 1=error
    if [ "$CS_EXIT" -eq 2 ]; then
        PROMISE_PASSED=false
        PROMISE_MESSAGE="$CS_OUTPUT"
    elif [ "$CS_EXIT" -eq 0 ]; then
        PROMISE_MESSAGE="$CS_OUTPUT"
    else
        # Error case - allow stop but note the error
        PROMISE_MESSAGE="Promise check error (allowing stop): $CS_OUTPUT"
    fi
fi

# If promises block, output immediately
if [ "$PROMISE_PASSED" = false ]; then
    output_json "block" "reason" "ðŸš« COMPLETION CRITERIA NOT MET

${PROMISE_MESSAGE}

To proceed:
1. Complete or verify your promises: cs-promise --mine
2. Or adopt/cancel orphaned promises
3. Session ID is auto-generated by ccsystem3"
    exit 0
fi

# --- Step 2: Orchestrator Guidance Check (orch-* sessions only) ---

if [[ "$SESSION_ID" == orch-* ]]; then
    # Use gtimeout on macOS (GNU coreutils), fallback to timeout on Linux
    TIMEOUT_CMD="timeout"
    if command -v gtimeout &> /dev/null; then
        TIMEOUT_CMD="gtimeout"
    fi

    ORCH_RESULT=$(cd "$PROJECT_ROOT" && $TIMEOUT_CMD 5s python3 << 'ORCH_CHECK'
import json
import sys
import os

sys.path.insert(0, os.path.join(os.environ.get('CLAUDE_PROJECT_DIR', os.getcwd()), '.claude', 'hooks'))

try:
    from unified_stop_gate.checkers import OrchestratorGuidanceChecker
    from unified_stop_gate.config import EnvironmentConfig, PathResolver

    config = EnvironmentConfig.from_env()
    paths = PathResolver(config=config)
    checker = OrchestratorGuidanceChecker(config, paths)
    result = checker.check()

    if not result.passed:
        print(json.dumps({"passed": False, "message": result.message}))
    else:
        print(json.dumps({"passed": True, "message": result.message}))
except Exception as e:
    print(json.dumps({"passed": True, "message": f"Orchestrator check error: {e}"}))
ORCH_CHECK
)
    TIMEOUT_EXIT=$?
    if [ $TIMEOUT_EXIT -eq 124 ]; then
        echo "âš ï¸  Orchestrator check timed out (5s), allowing stop" >&2
        ORCH_RESULT='{"passed": true, "message": "Check timed out, allowing stop"}'
    fi

    ORCH_PASSED=$(echo "$ORCH_RESULT" | jq -r '.passed // true')
    if [ "$ORCH_PASSED" = "false" ]; then
        ORCH_MSG=$(echo "$ORCH_RESULT" | jq -r '.message // ""')
        output_json "block" "reason" "$ORCH_MSG"
        exit 0
    fi
fi

# --- Step 3: Beads Sync Check ---
# Ensure beads changes are committed to git

BEADS_NEEDS_SYNC=false

if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    # Check if beads directory has uncommitted changes
    if git -C "$PROJECT_ROOT" status --porcelain .beads/ 2>/dev/null | grep -q .; then
        BEADS_NEEDS_SYNC=true
    fi
fi

if [ "$BEADS_NEEDS_SYNC" = true ]; then
    output_json "block" "reason" "ðŸš« BEADS SYNC REQUIRED

Beads directory has uncommitted changes. Run 'bd sync' before stopping.

Beads changes must be committed to git before stopping to prevent loss of work tracking.

To proceed:
1. Run: bd sync
2. Try stopping again"
    exit 0
fi

# --- Step 4: Todo Continuation Check ---
# Ensure at least one continuation todo exists (Momentum Maintenance Protocol)

HAS_CONTINUATION=false

if command -v jq &>/dev/null; then
    # Check most recent todo file for continuation items
    TODOS_DIR="$HOME/.claude/todos"
    if [ -d "$TODOS_DIR" ]; then
        LATEST_TODO=$(ls -t "$TODOS_DIR"/*.json 2>/dev/null | head -1)
        if [ -n "$LATEST_TODO" ]; then
            # Check for items containing continuation keywords
            if jq -r '.items[].description' "$LATEST_TODO" 2>/dev/null | grep -qiE 'bd ready|check for|next task|continuation|follow.*up|ask.*user|present.*option|seek.*feedback'; then
                HAS_CONTINUATION=true
            fi
        fi
    fi
fi

if [ "$HAS_CONTINUATION" = false ]; then
    output_json "block" "reason" "ðŸš« NO CONTINUATION TODO

To maintain momentum between sessions, add a continuation todo item before stopping.

Examples:
- \"Check bd ready for next available task\"
- \"Review beads for follow-up work\"
- \"Continue investigating X\"
- \"Ask user for feedback on Y using AskUserQuestion\"
- \"Present options to user for Z approach\"

This ensures work isn't abandoned and next session knows where to start.
Continuation items may include seeking user input/feedback via option questions.

To proceed:
1. Add a continuation todo using TodoWrite
2. Try stopping again"
    exit 0
fi

# --- Step 5: Work Available (INFORMATIONAL ONLY - NEVER BLOCKS) ---
# Show priority-ordered work, but always approve

READY_WORK=""

if [ -d "$PROJECT_ROOT/.beads" ] && command -v bd &>/dev/null; then
    # Get all open tasks, sort by priority (P0 â†’ P1 â†’ P2...), take top 5
    READY_WORK=$(bd list --status=open 2>/dev/null | grep -E '\[P[0-9]\]' | sort -t'[' -k2,2n | head -5) || READY_WORK=""
fi

# Build final message
MSG_PARTS="âœ… ${PROMISE_MESSAGE}"

# Only show work section if there's actual work (not just "No open issues")
if [ -n "$READY_WORK" ] && ! echo "$READY_WORK" | grep -q "No open issues"; then
    MSG_PARTS="${MSG_PARTS}

## ðŸš€ Available Work (Priority Order)

\`\`\`
${READY_WORK}
\`\`\`

**Decision Framework:**
- **Continue** if: P0-P2 tasks ready, clear implementation path
- **Stop** if: Only P3-P4 work, blocked on external factors, user feedback required

If continuing: Add specific todos and proceed autonomously."
fi

# Always approve (blocking happens earlier or not at all)
output_json "approve" "systemMessage" "$MSG_PARTS"
