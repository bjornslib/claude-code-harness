"""Tests for the Exploitation Retriever (Task 2.2.1).

Tests cover:
- ExploitationConfig validation and defaults
- RetrievalResult properties and construction
- ExploitationRetriever.retrieve() with mocked store and LLM
- Query augmentation via LLM (enabled/disabled/error)
- Multi-query search merging and de-duplication
- Score decay for augmented queries
- retrieve_for_spec() enriched query construction
- Filtered search (level, tags)
- Fallback when no LLM gateway provided
- Error handling and edge cases
"""

from __future__ import annotations

import json
from typing import Any
from unittest.mock import MagicMock, patch

import pytest

from zerorepo.llm.models import ModelTier
from zerorepo.ontology.models import FeatureNode, FeaturePath
from zerorepo.selection.exploitation import (
    ExploitationConfig,
    ExploitationRetriever,
    RetrievalResult,
    _AugmentedQueries,
)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


def _make_node(
    node_id: str,
    name: str,
    level: int = 1,
    parent_id: str | None = None,
) -> FeatureNode:
    """Create a FeatureNode for testing."""
    return FeatureNode(
        id=node_id,
        name=name,
        level=level,
        parent_id=parent_id,
        description=f"Description of {name}",
    )


def _make_path(node_id: str, name: str, score: float) -> FeaturePath:
    """Create a single-node FeaturePath for testing."""
    node = _make_node(node_id, name)
    return FeaturePath(nodes=[node], score=score)


@pytest.fixture
def mock_store() -> MagicMock:
    """Create a mock OntologyBackend."""
    store = MagicMock()
    store.search.return_value = [
        _make_path("auth", "Authentication", 0.9),
        _make_path("websocket", "WebSocket", 0.8),
        _make_path("react", "React Frontend", 0.7),
    ]
    store.search_with_filters.return_value = [
        _make_path("auth", "Authentication", 0.9),
    ]
    return store


@pytest.fixture
def mock_llm() -> MagicMock:
    """Create a mock LLMGateway."""
    llm = MagicMock()
    llm.select_model.return_value = "gpt-4o-mini"
    llm.complete.return_value = json.dumps({
        "queries": [
            "user authentication oauth",
            "real-time websocket messaging",
            "react frontend components",
        ]
    })
    return llm


@pytest.fixture
def config() -> ExploitationConfig:
    """Create a test configuration."""
    return ExploitationConfig(
        max_augmented_queries=3,
        top_k_per_query=5,
        score_decay=0.8,
        min_score=0.0,
        enable_augmentation=True,
    )


@pytest.fixture
def retriever(
    mock_store: MagicMock,
    mock_llm: MagicMock,
    config: ExploitationConfig,
) -> ExploitationRetriever:
    """Create a retriever with mock dependencies."""
    return ExploitationRetriever(
        store=mock_store,
        llm_gateway=mock_llm,
        config=config,
    )


# ---------------------------------------------------------------------------
# ExploitationConfig tests
# ---------------------------------------------------------------------------


class TestExploitationConfig:
    """Tests for ExploitationConfig."""

    def test_defaults(self) -> None:
        cfg = ExploitationConfig()
        assert cfg.augmentation_tier == ModelTier.CHEAP
        assert cfg.max_augmented_queries == 5
        assert cfg.top_k_per_query == 10
        assert cfg.score_decay == 0.85
        assert cfg.min_score == 0.0
        assert cfg.enable_augmentation is True

    def test_custom_values(self) -> None:
        cfg = ExploitationConfig(
            augmentation_tier=ModelTier.STRONG,
            max_augmented_queries=10,
            top_k_per_query=50,
            score_decay=0.9,
            min_score=0.3,
            enable_augmentation=False,
        )
        assert cfg.augmentation_tier == ModelTier.STRONG
        assert cfg.max_augmented_queries == 10
        assert cfg.score_decay == 0.9
        assert cfg.enable_augmentation is False

    def test_invalid_score_decay(self) -> None:
        with pytest.raises(Exception):
            ExploitationConfig(score_decay=0.0)

    def test_invalid_max_queries(self) -> None:
        with pytest.raises(Exception):
            ExploitationConfig(max_augmented_queries=0)


# ---------------------------------------------------------------------------
# RetrievalResult tests
# ---------------------------------------------------------------------------


class TestRetrievalResult:
    """Tests for RetrievalResult."""

    def test_empty_result(self) -> None:
        result = RetrievalResult(
            original_query="test",
            total_candidates=0,
        )
        assert result.count == 0
        assert result.top_result is None
        assert result.paths == []
        assert result.augmented_queries == []

    def test_with_paths(self) -> None:
        paths = [
            _make_path("a", "Feature A", 0.9),
            _make_path("b", "Feature B", 0.7),
        ]
        result = RetrievalResult(
            paths=paths,
            original_query="test query",
            augmented_queries=["expanded"],
            total_candidates=5,
        )
        assert result.count == 2
        assert result.top_result is not None
        assert result.top_result.leaf.id == "a"
        assert result.total_candidates == 5

    def test_metadata(self) -> None:
        result = RetrievalResult(
            original_query="test",
            retrieval_metadata={"key": "value"},
        )
        assert result.retrieval_metadata["key"] == "value"


# ---------------------------------------------------------------------------
# ExploitationRetriever tests
# ---------------------------------------------------------------------------


class TestExploitationRetriever:
    """Tests for ExploitationRetriever."""

    def test_properties(
        self,
        retriever: ExploitationRetriever,
        mock_store: MagicMock,
        config: ExploitationConfig,
    ) -> None:
        assert retriever.store is mock_store
        assert retriever.config is config

    def test_retrieve_basic(
        self, retriever: ExploitationRetriever, mock_store: MagicMock
    ) -> None:
        result = retriever.retrieve("real-time chat with React", top_k=10)

        assert isinstance(result, RetrievalResult)
        assert result.original_query == "real-time chat with React"
        assert len(result.augmented_queries) == 3
        assert result.count > 0
        # Store search was called (original + augmented queries)
        assert mock_store.search.call_count >= 1

    def test_retrieve_empty_query_raises(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="empty"):
            retriever.retrieve("")

    def test_retrieve_whitespace_query_raises(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="empty"):
            retriever.retrieve("   \n\t  ")

    def test_retrieve_invalid_top_k(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="positive"):
            retriever.retrieve("test", top_k=0)

    def test_retrieve_negative_top_k(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="positive"):
            retriever.retrieve("test", top_k=-5)


# ---------------------------------------------------------------------------
# Query augmentation tests
# ---------------------------------------------------------------------------


class TestQueryAugmentation:
    """Tests for LLM-based query augmentation."""

    def test_augmentation_enabled(
        self,
        retriever: ExploitationRetriever,
        mock_llm: MagicMock,
    ) -> None:
        result = retriever.retrieve("chat app", top_k=10)
        # LLM should have been called for augmentation
        mock_llm.select_model.assert_called()
        mock_llm.complete.assert_called()
        assert len(result.augmented_queries) == 3

    def test_augmentation_disabled(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm, config=cfg
        )
        result = retriever.retrieve("chat app", top_k=10)
        # LLM should NOT have been called
        mock_llm.complete.assert_not_called()
        assert result.augmented_queries == []

    def test_no_llm_gateway(self, mock_store: MagicMock) -> None:
        retriever = ExploitationRetriever(store=mock_store, llm_gateway=None)
        result = retriever.retrieve("chat app", top_k=10)
        assert result.augmented_queries == []
        # Only the original query was searched
        mock_store.search.assert_called_once()

    def test_augmentation_llm_error_fallback(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        mock_llm.complete.side_effect = RuntimeError("LLM unavailable")
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm
        )
        # Should not raise - falls back to original query
        result = retriever.retrieve("chat app", top_k=10)
        assert result.augmented_queries == []
        assert result.count > 0

    def test_augmentation_malformed_json(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        mock_llm.complete.return_value = "Not valid JSON at all"
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm
        )
        result = retriever.retrieve("chat app", top_k=10)
        # Falls back to line-based parsing
        assert isinstance(result.augmented_queries, list)

    def test_augmentation_json_in_text(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        mock_llm.complete.return_value = (
            'Here are the queries:\n{"queries": ["auth", "websocket"]}\n'
            "These should help."
        )
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm
        )
        result = retriever.retrieve("chat app", top_k=10)
        assert "auth" in result.augmented_queries
        assert "websocket" in result.augmented_queries


# ---------------------------------------------------------------------------
# Score decay and merging tests
# ---------------------------------------------------------------------------


class TestScoreDecayAndMerging:
    """Tests for score decay and result merging."""

    def test_score_decay_applied(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        # Original query returns auth with 0.9
        # Augmented query also returns auth with 0.9 â†’ decayed to 0.9*0.8=0.72
        # The original (0.9) should win
        cfg = ExploitationConfig(score_decay=0.8)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm, config=cfg
        )
        result = retriever.retrieve("auth", top_k=10)

        # Find the auth path - should have score 0.9 (original, not decayed)
        auth_paths = [p for p in result.paths if p.leaf.id == "auth"]
        assert len(auth_paths) == 1
        assert auth_paths[0].score == pytest.approx(0.9)

    def test_deduplication(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        # Same features returned by multiple queries should be de-duplicated
        cfg = ExploitationConfig(score_decay=0.8)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm, config=cfg
        )
        result = retriever.retrieve("auth", top_k=10)

        # Should only have unique leaf IDs
        leaf_ids = [p.leaf.id for p in result.paths]
        assert len(leaf_ids) == len(set(leaf_ids))

    def test_min_score_filter(self, mock_store: MagicMock) -> None:
        # Set min_score high to filter out low-scoring results
        mock_store.search.return_value = [
            _make_path("high", "High Score", 0.95),
            _make_path("low", "Low Score", 0.1),
        ]
        cfg = ExploitationConfig(
            enable_augmentation=False,
            min_score=0.5,
        )
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=None, config=cfg
        )
        result = retriever.retrieve("test", top_k=10)

        # Only high-score result should pass
        assert result.count == 1
        assert result.paths[0].leaf.id == "high"

    def test_top_k_respected(self, mock_store: MagicMock) -> None:
        mock_store.search.return_value = [
            _make_path(f"feat_{i}", f"Feature {i}", 1.0 - i * 0.1)
            for i in range(10)
        ]
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=None, config=cfg
        )
        result = retriever.retrieve("test", top_k=3)
        assert result.count == 3

    def test_results_sorted_by_score(self, mock_store: MagicMock) -> None:
        mock_store.search.return_value = [
            _make_path("low", "Low", 0.3),
            _make_path("high", "High", 0.9),
            _make_path("mid", "Mid", 0.6),
        ]
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=None, config=cfg
        )
        result = retriever.retrieve("test", top_k=10)
        scores = [p.score for p in result.paths]
        assert scores == sorted(scores, reverse=True)


# ---------------------------------------------------------------------------
# Filtered search tests
# ---------------------------------------------------------------------------


class TestFilteredSearch:
    """Tests for filtered retrieval (level, tags)."""

    def test_level_filter(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm, config=cfg
        )
        result = retriever.retrieve("test", top_k=10, level=2)
        mock_store.search_with_filters.assert_called()
        call_kwargs = mock_store.search_with_filters.call_args
        assert call_kwargs.kwargs.get("level") == 2 or (
            len(call_kwargs.args) > 2 and call_kwargs.args[2] == 2
        )

    def test_tag_filter(
        self, mock_store: MagicMock, mock_llm: MagicMock
    ) -> None:
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=mock_llm, config=cfg
        )
        result = retriever.retrieve("test", top_k=10, tags=["python"])
        mock_store.search_with_filters.assert_called()

    def test_no_filter_uses_basic_search(
        self, mock_store: MagicMock
    ) -> None:
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=None, config=cfg
        )
        result = retriever.retrieve("test", top_k=10)
        mock_store.search.assert_called()
        mock_store.search_with_filters.assert_not_called()


# ---------------------------------------------------------------------------
# retrieve_for_spec tests
# ---------------------------------------------------------------------------


class TestRetrieveForSpec:
    """Tests for retrieve_for_spec() enriched query."""

    def test_basic_spec(
        self, retriever: ExploitationRetriever, mock_store: MagicMock
    ) -> None:
        result = retriever.retrieve_for_spec(
            description="Build a chat application"
        )
        assert isinstance(result, RetrievalResult)
        assert "chat application" in result.original_query

    def test_enriched_query(
        self, retriever: ExploitationRetriever, mock_store: MagicMock
    ) -> None:
        result = retriever.retrieve_for_spec(
            description="Build a chat app",
            languages=["Python", "TypeScript"],
            frameworks=["FastAPI", "React"],
            core_functionality="real-time messaging",
        )
        query = result.original_query
        assert "chat app" in query
        assert "Python" in query
        assert "TypeScript" in query
        assert "FastAPI" in query
        assert "React" in query
        assert "real-time messaging" in query

    def test_empty_description_raises(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="empty"):
            retriever.retrieve_for_spec(description="")

    def test_whitespace_description_raises(
        self, retriever: ExploitationRetriever
    ) -> None:
        with pytest.raises(ValueError, match="empty"):
            retriever.retrieve_for_spec(description="   ")

    def test_spec_with_no_extras(
        self, retriever: ExploitationRetriever
    ) -> None:
        result = retriever.retrieve_for_spec(
            description="Simple CLI tool for data processing",
            languages=None,
            frameworks=None,
            core_functionality=None,
        )
        assert result.original_query == "Simple CLI tool for data processing"


# ---------------------------------------------------------------------------
# Edge case and error handling tests
# ---------------------------------------------------------------------------


class TestEdgeCases:
    """Tests for edge cases and error handling."""

    def test_empty_store_returns_empty(self, mock_llm: MagicMock) -> None:
        empty_store = MagicMock()
        empty_store.search.return_value = []
        empty_store.search_with_filters.return_value = []

        retriever = ExploitationRetriever(
            store=empty_store, llm_gateway=mock_llm
        )
        result = retriever.retrieve("test", top_k=10)
        assert result.count == 0

    def test_store_search_error(self, mock_llm: MagicMock) -> None:
        error_store = MagicMock()
        error_store.search.side_effect = RuntimeError("Store error")
        error_store.search_with_filters.side_effect = RuntimeError("Store error")

        retriever = ExploitationRetriever(
            store=error_store, llm_gateway=mock_llm
        )
        # Should not raise - handles errors per-query
        result = retriever.retrieve("test", top_k=10)
        # May have 0 results due to all queries failing
        assert isinstance(result, RetrievalResult)

    def test_retriever_without_llm_or_config(
        self, mock_store: MagicMock
    ) -> None:
        retriever = ExploitationRetriever(store=mock_store)
        assert retriever.config is not None  # Uses defaults
        result = retriever.retrieve("test", top_k=5)
        assert isinstance(result, RetrievalResult)

    def test_large_top_k(self, mock_store: MagicMock) -> None:
        cfg = ExploitationConfig(enable_augmentation=False)
        retriever = ExploitationRetriever(
            store=mock_store, llm_gateway=None, config=cfg
        )
        result = retriever.retrieve("test", top_k=1000)
        # Should work fine, just returns whatever the store has
        assert result.count <= 1000


# ---------------------------------------------------------------------------
# Import tests
# ---------------------------------------------------------------------------


class TestImports:
    """Tests for module imports."""

    def test_import_from_package(self) -> None:
        from zerorepo.selection import (
            ExploitationConfig,
            ExploitationRetriever,
            RetrievalResult,
        )
        assert ExploitationRetriever is not None
        assert ExploitationConfig is not None
        assert RetrievalResult is not None

    def test_import_from_module(self) -> None:
        from zerorepo.selection.exploitation import (
            ExploitationConfig,
            ExploitationRetriever,
            RetrievalResult,
            _AugmentedQueries,
        )
        assert _AugmentedQueries is not None


# ---------------------------------------------------------------------------
# _parse_augmented_response unit tests
# ---------------------------------------------------------------------------


class TestParseAugmentedResponse:
    """Tests for the _parse_augmented_response internal method."""

    @pytest.fixture
    def retriever_simple(self, mock_store: MagicMock) -> ExploitationRetriever:
        return ExploitationRetriever(store=mock_store)

    def test_valid_json(self, retriever_simple: ExploitationRetriever) -> None:
        text = '{"queries": ["auth", "react", "websocket"]}'
        result = retriever_simple._parse_augmented_response(text, 5)
        assert result == ["auth", "react", "websocket"]

    def test_json_in_text(self, retriever_simple: ExploitationRetriever) -> None:
        text = 'Sure! Here are queries:\n{"queries": ["auth", "react"]}\nHope this helps.'
        result = retriever_simple._parse_augmented_response(text, 5)
        assert result == ["auth", "react"]

    def test_plain_lines(self, retriever_simple: ExploitationRetriever) -> None:
        text = "- authentication\n- websocket messaging\n- react components"
        result = retriever_simple._parse_augmented_response(text, 5)
        assert "authentication" in result
        assert "websocket messaging" in result
        assert "react components" in result

    def test_empty_queries_filtered(
        self, retriever_simple: ExploitationRetriever
    ) -> None:
        text = '{"queries": ["auth", "", "   ", "react"]}'
        result = retriever_simple._parse_augmented_response(text, 5)
        assert result == ["auth", "react"]

    def test_max_queries_limit(
        self, retriever_simple: ExploitationRetriever
    ) -> None:
        text = json.dumps({"queries": [f"query_{i}" for i in range(20)]})
        result = retriever_simple._parse_augmented_response(text, 3)
        assert len(result) == 3

    def test_completely_invalid(
        self, retriever_simple: ExploitationRetriever
    ) -> None:
        text = "x"
        result = retriever_simple._parse_augmented_response(text, 5)
        # Too short to be a line either
        assert result == []
