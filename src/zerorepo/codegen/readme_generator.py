"""README.md generation for the generated repository.

Extracts project overview from RPG metadata and NL spec, generates
usage examples from RPG node examples, and lists key modules.
"""

from __future__ import annotations

from typing import Any

from zerorepo.codegen.models import CoverageReport
from zerorepo.models.graph import RPGGraph
from zerorepo.models.node import RPGNode


def generate_readme(
    graph: RPGGraph,
    project_metadata: dict[str, Any],
    nl_spec: str | None = None,
    coverage: CoverageReport | None = None,
) -> str:
    """Generate a complete README.md for the generated repository.

    Sections include:
    - Project title and description
    - Installation instructions
    - Usage examples (from RPG node examples)
    - Module overview
    - Testing instructions
    - Generation metadata

    Args:
        graph: The RPGGraph with node and metadata information.
        project_metadata: Project metadata dict.
        nl_spec: Optional natural language specification text.
        coverage: Optional coverage report for summary stats.

    Returns:
        The README.md content string.
    """
    name = project_metadata.get("name", "Generated Project")
    description = project_metadata.get("description", "")
    sections: list[str] = []

    # Title and description
    sections.append(f"# {name}")
    sections.append("")
    if description:
        sections.append(description)
        sections.append("")

    # Overview from NL spec
    if nl_spec:
        sections.append("## Overview")
        sections.append("")
        # Take first paragraph or first 500 chars
        overview = _extract_overview(nl_spec)
        sections.append(overview)
        sections.append("")

    # Installation
    sections.append("## Installation")
    sections.append("")
    sections.append("```bash")
    sections.append("# Clone the repository")
    sections.append(f"git clone <repository-url>")
    sections.append(f"cd {name}")
    sections.append("")
    sections.append("# Install in development mode")
    sections.append("pip install -e .")
    sections.append("")
    sections.append("# Install dev dependencies")
    sections.append("pip install -e '.[dev]'")
    sections.append("```")
    sections.append("")

    # Module overview
    modules = _extract_module_overview(graph)
    if modules:
        sections.append("## Modules")
        sections.append("")
        sections.append("| Module | Description | Functions |")
        sections.append("|--------|-------------|-----------|")
        for mod_name, mod_desc, func_count in modules:
            sections.append(f"| `{mod_name}` | {mod_desc} | {func_count} |")
        sections.append("")

    # Usage examples
    examples = _extract_usage_examples(graph)
    if examples:
        sections.append("## Usage Examples")
        sections.append("")
        for example_name, example_code in examples:
            sections.append(f"### {example_name}")
            sections.append("")
            sections.append("```python")
            sections.append(example_code)
            sections.append("```")
            sections.append("")

    # Testing
    sections.append("## Testing")
    sections.append("")
    sections.append("```bash")
    sections.append("# Run all tests")
    sections.append("pytest tests/")
    sections.append("")
    sections.append("# Run with coverage")
    sections.append("pytest tests/ --cov=src --cov-report=html")
    sections.append("```")
    sections.append("")

    # Coverage summary
    if coverage:
        sections.append("## Generation Summary")
        sections.append("")
        sections.append(f"- **Total nodes planned**: {coverage.total_nodes}")
        sections.append(f"- **Nodes passed**: {coverage.passed_nodes} ({coverage.pass_rate:.1f}%)")
        sections.append(f"- **Nodes failed**: {coverage.failed_nodes}")
        sections.append(f"- **Nodes skipped**: {coverage.skipped_nodes}")
        if coverage.generation_time_seconds:
            minutes = coverage.generation_time_seconds / 60
            sections.append(f"- **Generation time**: {minutes:.1f} minutes")
        sections.append("")

    # RPG artifact reference
    sections.append("## RPG Artifact")
    sections.append("")
    sections.append("The Repository Planning Graph used to generate this project")
    sections.append("is available at `docs/rpg.json`. This file contains the full")
    sections.append("node and edge structure including generation status and metadata.")
    sections.append("")

    # Footer
    sections.append("---")
    sections.append("")
    sections.append("*This repository was auto-generated by ZeroRepo Phase 4: Graph-Guided Code Generation.*")
    sections.append("")

    return "\n".join(sections)


def _extract_overview(nl_spec: str) -> str:
    """Extract a brief overview from the NL specification.

    Takes the first paragraph or first 500 characters, whichever is shorter.

    Args:
        nl_spec: The full NL specification text.

    Returns:
        A brief overview string.
    """
    # Split into paragraphs
    paragraphs = nl_spec.strip().split("\n\n")
    if paragraphs:
        first = paragraphs[0].strip()
        if len(first) > 500:
            return first[:497] + "..."
        return first
    return nl_spec[:500]


def _extract_module_overview(
    graph: RPGGraph,
) -> list[tuple[str, str, int]]:
    """Extract module-level overview from the RPG.

    Groups nodes by their file path directory and counts functions.

    Args:
        graph: The RPGGraph to analyze.

    Returns:
        A list of (module_name, description, function_count) tuples.
    """
    modules: dict[str, list[RPGNode]] = {}
    for node in graph.nodes.values():
        if not node.file_path:
            continue
        # Get the directory as module name
        parts = node.file_path.replace("\\", "/").split("/")
        if len(parts) >= 2:
            module = parts[-2] if parts[-2] != "src" else parts[-1].replace(".py", "")
        else:
            module = parts[0].replace(".py", "")
        modules.setdefault(module, []).append(node)

    result: list[tuple[str, str, int]] = []
    for mod_name, nodes in sorted(modules.items()):
        # Use the first node's docstring summary for description
        desc = ""
        for n in nodes:
            if n.docstring:
                first_line = n.docstring.strip().split("\n")[0]
                desc = first_line[:80]
                break
        if not desc:
            desc = f"{mod_name} module"
        result.append((mod_name, desc, len(nodes)))

    return result


def _extract_usage_examples(
    graph: RPGGraph,
    max_examples: int = 5,
) -> list[tuple[str, str]]:
    """Extract usage examples from RPG node metadata.

    Looks for nodes with example usage in their metadata or
    constructs simple examples from function signatures.

    Args:
        graph: The RPGGraph to scan.
        max_examples: Maximum number of examples to include.

    Returns:
        A list of (example_name, example_code) tuples.
    """
    examples: list[tuple[str, str]] = []

    for node in sorted(graph.nodes.values(), key=lambda n: n.name):
        if len(examples) >= max_examples:
            break

        # Check metadata for explicit examples
        if "example" in node.metadata:
            examples.append((node.name, str(node.metadata["example"])))
            continue

        # Generate simple example from signature
        if node.signature and node.file_path:
            module_path = node.file_path.replace("\\", "/").replace("/", ".").replace(".py", "")
            example = f"from {module_path} import {node.name}\n\n"
            example += f"# {node.docstring.strip().split(chr(10))[0] if node.docstring else 'Use ' + node.name}"
            example += f"\nresult = {node.signature}"
            examples.append((node.name, example))

    return examples
